// !$*UTF8*$!
{
	000D15A906AB0D7C00935F7C = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 1301}}";
			sepNavSelRange = "{1814, 0}";
			sepNavVisRect = "{{0, 486}, {964, 690}}";
		};
	};
	000D15AA06AB0D7C00935F7C = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 690}}";
			sepNavSelRange = "{1120, 0}";
			sepNavVisRect = "{{0, 0}, {964, 690}}";
		};
	};
	00122E9906B18A07007FA5FE = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 517}}";
			sepNavSelRange = "{1055, 7}";
			sepNavVisRect = "{{0, 0}, {964, 478}}";
		};
	};
	00122E9A06B18A07007FA5FE = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 7517}}";
			sepNavSelRange = "{5386, 240}";
			sepNavVisRect = "{{0, 2002}, {964, 468}}";
		};
	};
	00122EA406B1A7E5007FA5FE = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {967, 461}}";
			sepNavSelRange = "{136, 0}";
			sepNavVisRect = "{{0, 0}, {967, 461}}";
		};
	};
	00122EA506B1A7E5007FA5FE = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {968, 881}}";
			sepNavSelRange = "{3649, 0}";
			sepNavVisRect = "{{0, 420}, {968, 461}}";
		};
	};
	002E7DF506A86C6F00C9D931 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {963, 690}}";
			sepNavSelRange = "{1100, 0}";
			sepNavVisRect = "{{0, 0}, {963, 690}}";
		};
	};
	002E7DF606A86C6F00C9D931 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 2477}}";
			sepNavSelRange = "{7168, 7}";
			sepNavVisRect = "{{0, 1900}, {862, 330}}";
		};
	};
	002E7DF706A86C6F00C9D931 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {996, 713}}";
			sepNavSelRange = "{0, 0}";
			sepNavVisRect = "{{0, 0}, {996, 689}}";
		};
	};
	002E7DF806A86C6F00C9D931 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 1777}}";
			sepNavSelRange = "{3189, 0}";
			sepNavVisRect = "{{0, 1424}, {862, 330}}";
			sepNavWindowFrame = "{{15, 269}, {750, 558}}";
		};
	};
	002E7DFD06A86D7E00C9D931 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {967, 5851}}";
			sepNavSelRange = "{561, 0}";
			sepNavVisRect = "{{0, 0}, {967, 461}}";
		};
	};
	002E7DFE06A86D7E00C9D931 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {967, 532}}";
			sepNavSelRange = "{577, 0}";
			sepNavVisRect = "{{0, 0}, {967, 461}}";
		};
	};
	002F187907003E5A004F5FEF = {
		fileReference = 00CBA33F06DB8FDE000ACD19;
		functionName = "-pdfData";
		isa = PBXFileBreakpoint;
		lineNumber = 195;
		state = 1;
	};
	0035332F06A5DD5700AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 2422}}";
			sepNavSelRange = "{5881, 0}";
			sepNavVisRect = "{{0, 1820}, {964, 468}}";
		};
	};
	0035333006A5DD5700AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 2058}}";
			sepNavSelRange = "{5341, 0}";
			sepNavVisRect = "{{0, 1576}, {964, 468}}";
		};
	};
	0035333106A5DD5700AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 8120}}";
			sepNavSelRange = "{4775, 0}";
			sepNavVisRect = "{{0, 2475}, {964, 468}}";
		};
	};
	0035334106A5DD5700AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 1063}}";
			sepNavSelRange = "{1224, 0}";
			sepNavVisRect = "{{0, 420}, {964, 463}}";
			sepNavWindowFrame = "{{15, 269}, {750, 558}}";
		};
	};
	0035334806A5DD5700AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 573}}";
			sepNavSelRange = "{139, 0}";
			sepNavVisRect = "{{0, 0}, {964, 478}}";
		};
	};
	0035334A06A5DD5700AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {963, 690}}";
			sepNavSelRange = "{690, 0}";
			sepNavVisRect = "{{0, 0}, {963, 690}}";
		};
	};
	003533A106A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {996, 6355}}";
			sepNavSelRange = "{115, 0}";
			sepNavVisRect = "{{0, 0}, {996, 270}}";
		};
	};
	003533A206A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {996, 689}}";
			sepNavSelRange = "{0, 0}";
			sepNavVisRect = "{{0, 0}, {996, 689}}";
		};
	};
	003533A806A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {1239, 4395}}";
			sepNavSelRange = "{9455, 139}";
			sepNavVisRect = "{{0, 2903}, {1239, 425}}";
		};
	};
	003533A906A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 2757}}";
			sepNavSelRange = "{2954, 10}";
			sepNavVisRect = "{{0, 879}, {964, 468}}";
		};
	};
	003533AA06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 9239}}";
			sepNavSelRange = "{20893, 0}";
			sepNavVisRect = "{{0, 6965}, {964, 468}}";
		};
	};
	003533AB06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 11143}}";
			sepNavSelRange = "{7234, 0}";
			sepNavVisRect = "{{0, 2730}, {964, 468}}";
			sepNavWindowFrame = "{{38, 248}, {750, 558}}";
		};
	};
	003533AC06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 937}}";
			sepNavSelRange = "{2048, 0}";
			sepNavVisRect = "{{0, 445}, {964, 478}}";
		};
	};
	003533AD06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 7839}}";
			sepNavSelRange = "{17873, 0}";
			sepNavVisRect = "{{0, 6199}, {964, 468}}";
		};
	};
	003533AE06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 923}}";
			sepNavSelRange = "{1921, 29}";
			sepNavVisRect = "{{0, 431}, {964, 478}}";
		};
	};
	003533AF06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 6033}}";
			sepNavSelRange = "{7353, 0}";
			sepNavVisRect = "{{0, 3612}, {964, 478}}";
		};
	};
	003533B006A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 1133}}";
			sepNavSelRange = "{1401, 0}";
			sepNavVisRect = "{{0, 616}, {964, 463}}";
		};
	};
	003533B106A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 8105}}";
			sepNavSelRange = "{18118, 14}";
			sepNavVisRect = "{{0, 7361}, {964, 468}}";
		};
	};
	003533B306A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 2841}}";
			sepNavSelRange = "{828, 0}";
			sepNavVisRect = "{{0, 0}, {964, 690}}";
		};
	};
	003533B406A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 690}}";
			sepNavSelRange = "{554, 0}";
			sepNavVisRect = "{{0, 0}, {964, 690}}";
		};
	};
	003533B506A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {996, 755}}";
			sepNavSelRange = "{0, 0}";
			sepNavVisRect = "{{0, 0}, {996, 689}}";
		};
	};
	003533B606A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 4269}}";
			sepNavSelRange = "{6273, 0}";
			sepNavVisRect = "{{0, 2322}, {964, 478}}";
		};
	};
	003533B906A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {968, 1525}}";
			sepNavSelRange = "{1408, 0}";
			sepNavVisRect = "{{0, 374}, {968, 484}}";
		};
	};
	003533BA06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 10863}}";
			sepNavSelRange = "{20213, 14}";
			sepNavVisRect = "{{0, 9530}, {862, 330}}";
		};
	};
	003533BF06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 2631}}";
			sepNavSelRange = "{1346, 754}";
			sepNavVisRect = "{{0, 524}, {964, 478}}";
		};
	};
	003533C006A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 20817}}";
			sepNavSelRange = "{48812, 14}";
			sepNavVisRect = "{{0, 19876}, {862, 330}}";
		};
	};
	003533C106A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 2477}}";
			sepNavSelRange = "{1243, 0}";
			sepNavVisRect = "{{0, 244}, {964, 478}}";
		};
	};
	003533C206A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {2096, 12179}}";
			sepNavSelRange = "{2214, 0}";
			sepNavVisRect = "{{0, 712}, {1239, 410}}";
		};
	};
	003533C306A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 1847}}";
			sepNavSelRange = "{1676, 7}";
			sepNavVisRect = "{{0, 640}, {862, 330}}";
		};
	};
	003533C406A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 14881}}";
			sepNavSelRange = "{1226, 0}";
			sepNavVisRect = "{{0, 448}, {964, 468}}";
		};
	};
	003533C806A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {996, 689}}";
			sepNavSelRange = "{69, 0}";
			sepNavVisRect = "{{0, 0}, {996, 689}}";
		};
	};
	003533C906A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 3640}}";
			sepNavSelRange = "{780, 0}";
			sepNavVisRect = "{{0, 0}, {964, 478}}";
		};
	};
	003533CC06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {996, 689}}";
			sepNavSelRange = "{943, 0}";
			sepNavVisRect = "{{0, 0}, {996, 689}}";
		};
	};
	003533CD06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {996, 1721}}";
			sepNavSelRange = "{0, 0}";
			sepNavVisRect = "{{0, 0}, {996, 689}}";
		};
	};
	003533CE06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 478}}";
			sepNavSelRange = "{0, 0}";
			sepNavVisRect = "{{0, 0}, {964, 478}}";
		};
	};
	003533CF06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 4773}}";
			sepNavSelRange = "{733, 0}";
			sepNavVisRect = "{{0, 1372}, {964, 478}}";
		};
	};
	003533D006A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 478}}";
			sepNavSelRange = "{495, 0}";
			sepNavVisRect = "{{0, 0}, {964, 478}}";
		};
	};
	003533D106A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 5445}}";
			sepNavSelRange = "{10373, 98}";
			sepNavVisRect = "{{0, 3534}, {964, 478}}";
		};
	};
	003533D606A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {333, 1945}}";
			sepNavSelRange = "{1090, 24}";
			sepNavVisRect = "{{0, 491}, {333, 209}}";
		};
	};
	003533D906A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {674, 350}}";
			sepNavSelRange = "{122, 0}";
			sepNavVisRect = "{{0, 0}, {674, 250}}";
		};
	};
	003533F106A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {996, 5194}}";
			sepNavSelRange = "{774, 0}";
			sepNavVisRect = "{{0, 0}, {996, 689}}";
		};
	};
	003533F506A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 910}}";
			sepNavSelRange = "{1575, 0}";
			sepNavVisRect = "{{0, 364}, {964, 478}}";
		};
	};
	003533F606A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 2589}}";
			sepNavSelRange = "{1824, 44}";
			sepNavVisRect = "{{0, 484}, {964, 468}}";
			sepNavWindowFrame = "{{61, 227}, {750, 558}}";
		};
	};
	003533F706A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 937}}";
			sepNavSelRange = "{1767, 0}";
			sepNavVisRect = "{{0, 432}, {964, 478}}";
		};
	};
	003533F806A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 4367}}";
			sepNavSelRange = "{9361, 0}";
			sepNavVisRect = "{{0, 3878}, {964, 468}}";
			sepNavWindowFrame = "{{61, 227}, {750, 558}}";
		};
	};
	003533FA06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 1161}}";
			sepNavSelRange = "{81, 31}";
			sepNavVisRect = "{{0, 0}, {964, 468}}";
		};
	};
	003533FB06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 11689}}";
			sepNavSelRange = "{26296, 0}";
			sepNavVisRect = "{{0, 9909}, {964, 468}}";
		};
	};
	003533FC06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {996, 689}}";
			sepNavSelRange = "{0, 0}";
			sepNavVisRect = "{{0, 0}, {996, 689}}";
		};
	};
	0035340006A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 690}}";
			sepNavSelRange = "{1037, 18}";
			sepNavVisRect = "{{0, 0}, {964, 690}}";
		};
	};
	0035340C06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {968, 666}}";
			sepNavSelRange = "{964, 0}";
			sepNavVisRect = "{{0, 0}, {968, 666}}";
		};
	};
	0035340D06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 2239}}";
			sepNavSelRange = "{1655, 0}";
			sepNavVisRect = "{{0, 574}, {964, 468}}";
		};
	};
	0035340F06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 1385}}";
			sepNavSelRange = "{2292, 0}";
			sepNavVisRect = "{{0, 910}, {964, 463}}";
		};
	};
	0035341006A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {1124, 1890}}";
			sepNavSelRange = "{1124, 17}";
			sepNavVisRect = "{{0, 0}, {964, 463}}";
		};
	};
	0035341206A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 1273}}";
			sepNavSelRange = "{1947, 14}";
			sepNavVisRect = "{{0, 906}, {862, 330}}";
		};
	};
	0035341306A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {996, 503}}";
			sepNavSelRange = "{1038, 0}";
			sepNavVisRect = "{{0, 222}, {996, 270}}";
		};
	};
	0035341406A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 1945}}";
			sepNavSelRange = "{2123, 0}";
			sepNavVisRect = "{{0, 546}, {964, 468}}";
		};
	};
	0035341506A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {968, 587}}";
			sepNavSelRange = "{1151, 14}";
			sepNavVisRect = "{{0, 0}, {968, 461}}";
		};
	};
	0035341606A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 5557}}";
			sepNavSelRange = "{2894, 14}";
			sepNavVisRect = "{{0, 1116}, {862, 330}}";
		};
	};
	0035341706A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {996, 689}}";
			sepNavSelRange = "{0, 0}";
			sepNavVisRect = "{{0, 0}, {996, 689}}";
		};
	};
	0035341806A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 1665}}";
			sepNavSelRange = "{3613, 14}";
			sepNavVisRect = "{{0, 1284}, {862, 330}}";
		};
	};
	0035341A06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {967, 4661}}";
			sepNavSelRange = "{9872, 0}";
			sepNavVisRect = "{{0, 225}, {967, 461}}";
		};
	};
	0035341B06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {996, 545}}";
			sepNavSelRange = "{1026, 0}";
			sepNavVisRect = "{{0, 275}, {996, 270}}";
		};
	};
	0035341C06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 2883}}";
			sepNavSelRange = "{4449, 9}";
			sepNavVisRect = "{{0, 1954}, {964, 468}}";
		};
	};
	0035341E06A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 2379}}";
			sepNavSelRange = "{3082, 0}";
			sepNavVisRect = "{{0, 1131}, {964, 468}}";
		};
	};
	0035342006A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {996, 713}}";
			sepNavSelRange = "{966, 0}";
			sepNavVisRect = "{{0, 0}, {996, 689}}";
		};
	};
	0035342106A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 3919}}";
			sepNavSelRange = "{9300, 7}";
			sepNavVisRect = "{{0, 3552}, {862, 330}}";
		};
	};
	0035342206A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 587}}";
			sepNavSelRange = "{971, 0}";
			sepNavVisRect = "{{0, 0}, {964, 463}}";
		};
	};
	0035342306A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 4745}}";
			sepNavSelRange = "{10872, 7}";
			sepNavVisRect = "{{0, 4415}, {862, 330}}";
		};
	};
	0035342406A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {963, 811}}";
			sepNavSelRange = "{1352, 0}";
			sepNavVisRect = "{{0, 98}, {963, 690}}";
		};
	};
	0035342506A5DD8500AB4577 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 1805}}";
			sepNavSelRange = "{3826, 7}";
			sepNavVisRect = "{{0, 1340}, {862, 330}}";
		};
	};
	0046467B0789A61A005B890E = {
		fRef = 003533FB06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "GPSController.m: 708";
		rLen = 0;
		rLoc = 26117;
		rType = 0;
		vrLen = 917;
		vrLoc = 25486;
	};
	0046467E0789A69D005B890E = {
		fRef = 003533FB06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "GPSController.m: 708";
		rLen = 0;
		rLoc = 26117;
		rType = 0;
		vrLen = 917;
		vrLoc = 25486;
	};
	0046467F0789A69D005B890E = {
		fRef = 0035341C06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = sendFrame;
		rLen = 9;
		rLoc = 4449;
		rType = 0;
		vrLen = 835;
		vrLoc = 4068;
	};
	004646800789A69D005B890E = {
		fRef = 003533C406A5DD8500AB4577;
		isa = PBXBookmark;
	};
	004646810789A69D005B890E = {
		fRef = 003533FB06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "GPSController.m: 708";
		rLen = 0;
		rLoc = 26117;
		rType = 0;
		vrLen = 917;
		vrLoc = 25486;
	};
	004646820789A69D005B890E = {
		fRef = 0035341C06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = sendFrame;
		rLen = 9;
		rLoc = 4449;
		rType = 0;
		vrLen = 835;
		vrLoc = 4068;
	};
	004646830789A69D005B890E = {
		fRef = 003533C406A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "WaveScanner.mm: 35";
		rLen = 0;
		rLoc = 1226;
		rType = 0;
		vrLen = 628;
		vrLoc = 1132;
	};
	004646840789A706005B890E = {
		fRef = 003533C406A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "WaveScanner.mm: 35";
		rLen = 0;
		rLoc = 1226;
		rType = 0;
		vrLen = 628;
		vrLoc = 1132;
	};
	004646850789A71F005B890E = {
		fRef = 003533C406A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "WaveScanner.mm: 35";
		rLen = 0;
		rLoc = 1226;
		rType = 0;
		vrLen = 628;
		vrLoc = 1132;
	};
	004646880789A80A005B890E = {
		fRef = 003533C406A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "WaveScanner.mm: 35";
		rLen = 0;
		rLoc = 1226;
		rType = 0;
		vrLen = 628;
		vrLoc = 1132;
	};
	004646890789A80A005B890E = {
		fRef = 003533C406A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "WaveScanner.mm: 35";
		rLen = 0;
		rLoc = 1226;
		rType = 0;
		vrLen = 628;
		vrLoc = 1132;
	};
	0046468A0789A80A005B890E = {
		fRef = 003533FB06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "GPSController.m: 733";
		rLen = 0;
		rLoc = 26931;
		rType = 0;
		vrLen = 868;
		vrLoc = 25863;
	};
	0046468B0789A813005B890E = {
		fRef = 003533FB06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "GPSController.m: 715";
		rLen = 0;
		rLoc = 26296;
		rType = 0;
		vrLen = 868;
		vrLoc = 25863;
	};
	0046468C0789A82A005B890E = {
		fRef = 003533FB06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "GPSController.m: 715";
		rLen = 0;
		rLoc = 26296;
		rType = 0;
		vrLen = 868;
		vrLoc = 25863;
	};
	0046468D0789A837005B890E = {
		fRef = 003533FB06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "GPSController.m: 715";
		rLen = 0;
		rLoc = 26296;
		rType = 0;
		vrLen = 868;
		vrLoc = 25863;
	};
	0046468E0789A8BC005B890E = {
		fRef = 003533FB06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "GPSController.m: 715";
		rLen = 0;
		rLoc = 26296;
		rType = 0;
		vrLen = 868;
		vrLoc = 25863;
	};
	005B12660730051A00906C36 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 825}}";
			sepNavSelRange = "{1346, 7}";
			sepNavVisRect = "{{0, 458}, {862, 330}}";
		};
	};
	005B12670730051A00906C36 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 4339}}";
			sepNavSelRange = "{8694, 6}";
			sepNavVisRect = "{{0, 3606}, {964, 468}}";
		};
	};
	005E817006FDCFF20016F5E7 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {963, 690}}";
			sepNavSelRange = "{1170, 107}";
			sepNavVisRect = "{{0, 0}, {963, 690}}";
		};
	};
	005E817106FDCFF20016F5E7 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 4451}}";
			sepNavSelRange = "{5820, 14}";
			sepNavVisRect = "{{0, 1858}, {862, 330}}";
		};
	};
	006300060764D4FC003B81CC = {
		fRef = 0035341406A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "WaveDriverAirport.m: 53";
		rLen = 0;
		rLoc = 2123;
		rType = 0;
		vrLen = 1262;
		vrLoc = 1474;
	};
	006300080764D4FC003B81CC = {
		fRef = 0035341406A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "WaveDriverAirport.m: 53";
		rLen = 0;
		rLoc = 2123;
		rType = 0;
		vrLen = 1262;
		vrLoc = 1474;
	};
	0063000F0764D9CE003B81CC = {
		fRef = 003533AB06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "ScanControllerMenus.m: 276";
		rLen = 0;
		rLoc = 9901;
		rType = 0;
		vrLen = 1364;
		vrLoc = 9003;
	};
	006300200764DC82003B81CC = {
		fRef = 003533AA06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "ScanController.m: dealloc";
		rLen = 0;
		rLoc = 20893;
		rType = 0;
		vrLen = 897;
		vrLoc = 20396;
	};
	006300210764DC82003B81CC = {
		fRef = 003533AA06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "ScanController.m: dealloc";
		rLen = 0;
		rLoc = 20893;
		rType = 0;
		vrLen = 897;
		vrLoc = 20396;
	};
	006302200764FCA8003B81CC = {
		fRef = 003533AD06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "ScanControllerPrivate.m: 462";
		rLen = 0;
		rLoc = 17873;
		rType = 0;
		vrLen = 1120;
		vrLoc = 17034;
	};
	006302210764FCA8003B81CC = {
		fRef = 003533AD06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "ScanControllerPrivate.m: 462";
		rLen = 0;
		rLoc = 17873;
		rType = 0;
		vrLen = 1120;
		vrLoc = 17034;
	};
	0076657F07844A6400A30713 = {
		fRef = 003533AB06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "ScanControllerMenus.m: 204";
		rLen = 0;
		rLoc = 7234;
		rType = 0;
		vrLen = 1111;
		vrLoc = 6862;
	};
	0076658007844A6400A30713 = {
		fRef = 0035333106A5DD5700AB4577;
		isa = PBXTextBookmark;
		name = "vendor.db: 196";
		rLen = 0;
		rLoc = 4775;
		rType = 0;
		vrLen = 798;
		vrLoc = 4316;
	};
	0076658107844A6400A30713 = {
		fRef = 003533B106A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = sleepUntilDate;
		rLen = 14;
		rLoc = 18118;
		rType = 0;
		vrLen = 890;
		vrLoc = 17568;
	};
	0076658407844A6400A30713 = {
		fRef = 0035333106A5DD5700AB4577;
		isa = PBXTextBookmark;
		name = "vendor.db: 196";
		rLen = 0;
		rLoc = 4775;
		rType = 0;
		vrLen = 798;
		vrLoc = 4316;
	};
	0076658507844A6400A30713 = {
		fRef = 003533B106A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = sleepUntilDate;
		rLen = 14;
		rLoc = 18118;
		rType = 0;
		vrLen = 890;
		vrLoc = 17568;
	};
	0076658C0784503B00A30713 = {
		fRef = 0035341C06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = sendFrame;
		rLen = 9;
		rLoc = 4449;
		rType = 0;
		vrLen = 816;
		vrLoc = 4088;
	};
	007665910784504B00A30713 = {
		isa = PBXFileReference;
		lastKnownFileType = sourcecode.c.objc;
		name = GPSController.m;
		path = "/Users/mick/Library/Mail/POP-mick%binaervarianz.de@mail3.netbeat.de/INBOX.mbox/one_quirk___some_new.mimeattach/GPSController.m";
		refType = 0;
		sourceTree = "<absolute>";
	};
	00766A260784506900A30713 = {
		fRef = 007665910784504B00A30713;
		isa = PBXTextBookmark;
		name = "/*\n        \n        File:\t\t\tGPSController.m\n        Program:\t\tKisMAC\n\tAuthor:\t\t\tMichael Rossberg\n                                mick@binaervarianz.de\n\tDescription:\t\tKisMAC is a wireless stumbler for MacOS X.\n                \n        This file is part of KisMAC.\n        \n        Parts of this file are based on bsd airtools by h1kari.\n\n    KisMAC is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    KisMAC is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with KisMAC; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\n#import \"GPSController.h\"\n#import \"WaveHelper.h\"\n#import \"KisMACNotifications.h\"\n#import \"Trace.h\"\n\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/uio.h>\n#include <sys/vnode.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <string.h>\n#include <errno.h>\n\n#include <sys/termios.h>\n\nstruct termios ttyset;\n\n#define MAX_GPSBUF_LEN 1024\n#define VELOCITY_UNIT \"km/h\"\n#define VELOCITY_CONVERSION 1.852\n#define DISTANCE_UNIT \"km\"\n\n@interface GPSController(PrivateExtension) \n    - (void)setStatus:(NSString*)status;\n@end\n\n@implementation GPSController\n\n- (id)init {\n    _gpsLock = [[NSLock alloc] init];\n    _gpsThreadUp    = NO;\n    _gpsShallRun    = NO;\n    _debugEnabled   = NO;\n    _lastAdd        = [[NSDate date] retain];\n    _linesRead      = 0;\n\n    [self setStatus:NSLocalizedString(@\"GPS subsystem initialized but not running.\", @\"GPS status\")];\n\n    return self;\n}\n\n- (bool)startForDevice:(NSString*) device {\n    _reliable = NO;\n    _ns.dir = 'N';\n    _ns.coordinates = 0;\n    _ew.dir = 'E';\n    _ew.coordinates = 0;\n    _elev.coordinates = 0;\n    _elev.dir = 'm';\n    _velkt = 0;\n\t_peakvel = 0;\n    _veldir = -1;\n    _numsat = -1;\n    _hdop = 100;\n\t_sectordist = 0;\n\t_sectortime = 0;\n\t_totaldist = 0;\n\n    [self stop];\n    \n    [WaveHelper secureReplace:&_gpsDevice withObject:device];\n    [WaveHelper secureRelease:&_lastUpdate];\n    [WaveHelper secureRelease:&_sectorStart];\n    \n    if ([_gpsDevice length]==0) {\n        NSLog(@\"GPS integration disabled\");\n        [self setStatus:NSLocalizedString(@\"GPS subsystem disabled.\", @\"GPS status\")];\n        return NO;\n    }\n\n    [self setStatus:NSLocalizedString(@\"Starting GPS subsystem.\", @\"GPS status\")];\n    \n    if ([_gpsDevice isEqualToString:@\"GPSd\"]) [NSThread detachNewThreadSelector:@selector(gpsThreadGPSd:) toTarget:self withObject:Nil];\n    else [NSThread detachNewThreadSelector:@selector(gpsThreadSerial:) toTarget:self withObject:Nil];\n    return YES;\n}\n\n#pragma mark -\n\n- (bool)reliable {\n    return _reliable;\n}\n\n- (bool)gpsRunning {\n    return _gpsThreadUp;\n}\n\n- (NSString*) NSCoord {\n    if (_ns.coordinates==0) return nil;\n    return [NSString stringWithFormat:@\"%f%c\",_ns.coordinates, _ns.dir];\n}\n\n- (NSString*) EWCoord {\n    if (_ew.coordinates==0) return nil;\n    return [NSString stringWithFormat:@\"%f%c\",_ew.coordinates, _ew.dir];\n}\n\n- (NSString*) ElevCoord {\n    if (_elev.coordinates==0) return [NSString stringWithFormat:@\"No Elevation Data\"];\n    //NSLog([NSString stringWithFormat:@\"%f\",_elev.coordinates]);\n    return [NSString stringWithFormat:@\"%.1f %c/%.1f ft\",_elev.coordinates, _elev.dir, (_elev.coordinates * 3.2808399)]; //don't know if formatting stuff is correct\n}\n\n- (NSString*) VelKt {\n\tfloat velconv,peakconv,maxconv;\n\tvelconv = _velkt * VELOCITY_CONVERSION;\n\tpeakconv = _peakvel * VELOCITY_CONVERSION;\n\tmaxconv = _maxvel * VELOCITY_CONVERSION;\n\tif (_velkt==_maxvel) {\n\t\tif (_veldir==-1) return [NSString stringWithFormat:@\"%.1f %s (%.1f kt) [MAX]\",velconv,VELOCITY_UNIT,_velkt];\n\t\treturn [NSString stringWithFormat:@\"%.1f %s (%.1f kt) [MAX]\\nTrack: %d T\",velconv,VELOCITY_UNIT,_velkt,_veldir];\n\t} else if (_velkt==_peakvel) {\n\t\tif (_veldir==-1) return [NSString stringWithFormat:@\"%.1f %s (%.1f kt) [PEAK]\",velconv,VELOCITY_UNIT,_velkt];\n\t\treturn [NSString stringWithFormat:@\"%.1f %s (%.1f kt) [PEAK]\\nTrack: %d T\",velconv,VELOCITY_UNIT,_velkt,_veldir];\n\t} else {\n\t\tif (_veldir==-1) return [NSString stringWithFormat:@\"%.1f %s (%.1f kt) [peak: %.1f, max: %.1f]\",velconv,VELOCITY_UNIT,_velkt,peakconv,maxconv];\n\t\treturn [NSString stringWithFormat:@\"%.1f %s (%.1f kt) [peak: %.1f, max: %.1f]\\nTrack: %d T\",velconv,VELOCITY_UNIT,_velkt,peakconv,maxconv,_veldir];\n\t}\n}\n\n- (NSString*) DistStats {\n\tint sectortime;\n\tint sterror=0;\n\tfloat timeinterval;\n\tsectortime = (int)_sectortime;\n\n\tif (_sectorStart && (sectortime > 0)) {\n\t\ttimeinterval = [[NSDate date] timeIntervalSinceDate:_sectorStart];\n\t\tsterror = sectortime - (int)timeinterval;\n\t\t// remove negative error that develops after stopping\n\t\tif ((_velkt == 0) && (sterror < 0)) sterror = 0;\n\t}\n\t\n\tif (sterror == 0) {\n\t\tif (sectortime > 3600) return [NSString stringWithFormat:@\"Sector: %.1f %s (%.1f nm) in %d:%02d:%02d (avg: %.1f %s)\\nTotal: %.1f %s (%.1f nm)\",(_sectordist * VELOCITY_CONVERSION),DISTANCE_UNIT,_sectordist,(sectortime/3600),(sectortime%3600/60),(sectortime%60),(3600 * _sectordist * VELOCITY_CONVERSION)/_sectortime,VELOCITY_UNIT,(_totaldist * VELOCITY_CONVERSION),DISTANCE_UNIT,_totaldist];\n\t\telse if (sectortime > 60) return [NSString stringWithFormat:@\"Sector: %.1f %s (%.1f nm) in %d:%02d (avg: %.1f %s)\\nTotal: %.1f %s (%.1f nm)\",(_sectordist * VELOCITY_CONVERSION),DISTANCE_UNIT,_sectordist,(sectortime/60),(sectortime%60),(3600 * _sectordist * VELOCITY_CONVERSION)/_sectortime,VELOCITY_UNIT,(_totaldist * VELOCITY_CONVERSION),DISTANCE_UNIT,_totaldist];\n\t\telse if (sectortime > 0) return [NSString stringWithFormat:@\"Sector: %.1f %s (%.1f nm) in %d seconds (avg: %.1f %s)\\nTotal: %.1f %s (%.1f nm)\",(_sectordist * VELOCITY_CONVERSION),DISTANCE_UNIT,_sectordist,sectortime,(3600 * _sectordist * VELOCITY_CONVERSION)/_sectortime,VELOCITY_UNIT,(_totaldist * VELOCITY_CONVERSION),DISTANCE_UNIT,_totaldist];\n\t\telse return [NSString stringWithFormat:@\"Total: %.1f %s (%.1f nm)\",(_totaldist * VELOCITY_CONVERSION),DISTANCE_UNIT,_totaldist];\n\t} else {\n\t\tif (sectortime > 3600) return [NSString stringWithFormat:@\"Sector: %.1f %s (%.1f nm) in %d:%02d:%02d [ERROR: %ds] (avg: %.1f %s)\\nTotal: %.1f %s (%.1f nm)\",(_sectordist * VELOCITY_CONVERSION),DISTANCE_UNIT,_sectordist,(sectortime/3600),(sectortime%3600/60),(sectortime%60),sterror,(3600 * _sectordist * VELOCITY_CONVERSION)/_sectortime,VELOCITY_UNIT,(_totaldist * VELOCITY_CONVERSION),DISTANCE_UNIT,_totaldist];\n\t\telse if (sectortime > 60) return [NSString stringWithFormat:@\"Sector: %.1f %s (%.1f nm) in %d:%02d [ERROR: %ds] (avg: %.1f %s)\\nTotal: %.1f %s (%.1f nm)\",(_sectordist * VELOCITY_CONVERSION),DISTANCE_UNIT,_sectordist,(sectortime/60),(sectortime%60),sterror,(3600 * _sectordist * VELOCITY_CONVERSION)/_sectortime,VELOCITY_UNIT,(_totaldist * VELOCITY_CONVERSION),DISTANCE_UNIT,_totaldist];\n\t\telse return [NSString stringWithFormat:@\"Sector: %.1f %s (%.1f nm) in %d seconds [ERROR: %ds] (avg: %.1f %s)\\nTotal: %.1f %s (%.1f nm)\",(_sectordist * VELOCITY_CONVERSION),DISTANCE_UNIT,_sectordist,sectortime,sterror,(3600 * _sectordist * VELOCITY_CONVERSION)/_sectortime,VELOCITY_UNIT,(_totaldist * VELOCITY_CONVERSION),DISTANCE_UNIT,_totaldist];\n\t}\n}\n\n- (NSString*) QualData {\n\tif (_numsat==-1) return [NSString stringWithFormat:@\"\"];\n\tif (_hdop>=50 || _hdop==0) return [NSString stringWithFormat:@\" (%d sats)\",_numsat];\n\treturn [NSString stringWithFormat:@\" (%d sats, HDOP %.1f)\",_numsat,_hdop];\n}\n\n- (NSString*)status {\n    if (_status) return _status;\n    \n    if (_lastUpdate)\n        if (_elev.coordinates) \n            if ((_velkt || _maxvel) && _reliable) // only report velocity if we're sure\n                return [NSString stringWithFormat:@\"%@: %@ %@\\n%@: %@\\n%@: %@\\n%@\\n%@: %@%@\", \n                        NSLocalizedString(@\"Position\", \"GPS status string.\"), \n                        [self NSCoord],[self EWCoord],\n                        NSLocalizedString(@\"Elevation\", \"GPS status string.\"), \n                        [self ElevCoord],\n                        NSLocalizedString(@\"Velocity\", \"GPS status string.\"), \n                        [self VelKt],[self DistStats],\n\t\t\t\t\t\tNSLocalizedString(@\"Time\", \"GPS status string.\"), \n\t\t\t\t\t\t[self lastUpdate],[self QualData]];\n            else\n                return [NSString stringWithFormat:@\"%@: %@ %@\\n%@: %@\\n%@: %@%@%@\", \n                        NSLocalizedString(@\"Position\", \"GPS status string.\"), \n                        [self NSCoord],[self EWCoord],\n                        NSLocalizedString(@\"Elevation\", \"GPS status string.\"), \n                        [self ElevCoord],\n\t\t\t\t\t\tNSLocalizedString(@\"Time\", \"GPS status string.\"), \n\t\t\t\t\t\t[self lastUpdate],\n                        _reliable ? @\"\" : NSLocalizedString(@\" -- NO FIX\", \"GPS status string. Needs leading space\"),\n                        [self QualData]];\n        else\n            return [NSString stringWithFormat:@\"%@: %@ %@\\n%@%@\", \n                NSLocalizedString(@\"Position\", \"GPS status string.\"), \n                [self NSCoord],[self EWCoord],\n                [self lastUpdate],\n                _reliable ? @\"\" : NSLocalizedString(@\" -- NO FIX\", \"GPS status string. Needs leading space\"),\n\t\t\t\t[self QualData]];\n\n    else if ([(NSString*)[[NSUserDefaults standardUserDefaults] objectForKey:@\"GPSDevice\"] length]) {\n        if (_gpsThreadUp) return NSLocalizedString(@\"GPS subsystem works, but there is no data.\\nIf you are using gpsd, there may be no GPS connected.\\nOtherwise, your GPS is probably connected but not yet reporting a position.\", \"GPS status string\");\n        else  return NSLocalizedString(@\"GPS not working\", \"LONG GPS status string with informations howto debug\");\n            //@\"GPS subsystem is not working. See log file for more details.\"\n    } else return NSLocalizedString(@\"GPS disabled\", \"LONG GPS status string with informations where to enable\");\n            //@\"GPS subsystem is disabled. You have to select a device in the preferences window.\"\n}\n\n- (void)setStatus:(NSString*)status {\n    [WaveHelper secureReplace:&_status withObject:status];\n    [[NSNotificationCenter defaultCenter] postNotificationName:KisMACGPSStatusChanged object:_status];\n}\n\n- (waypoint) currentPoint {\n    waypoint w;\n    \n    w._lat =_ns.coordinates * ((_ns.dir=='N') ? 1.0 : -1.0);\n    w._long=_ew.coordinates * ((_ew.dir=='E') ? 1.0 : -1.0);\n    w._elevation=_elev.coordinates;\n    \n    return w;\n}\n\n- (void) resetTrace {\n    [[WaveHelper trace] setTrace:nil];\n}\n\n- (void)setTraceInterval:(int)interval {\n    _traceInterval = interval;\n}\n- (void)setTripmateMode:(bool)mode {\n    _tripmateMode = mode;\n}\n\n- (void) setCurrentPointNS:(double)ns EW:(double)ew ELV:(double)elv{  //need to add elevation support here\n    waypoint w;\n    _ns.dir = (ns<0 ? 'S' : 'N');\n    _ew.dir = (ew<0 ? 'W' : 'E');\n    \n    _ns.coordinates = fabs(ns);\n    _ew.coordinates = fabs(ew); \n    \n    [WaveHelper secureReplace:&_lastUpdate withObject:[NSDate date]];\n    [WaveHelper secureReplace:&_lastAdd withObject:[NSDate date]];\n    \n    if (abs(ns)>=0 && abs(ns)<=90 && abs(ew)>=0 && abs(ew)<=180) {\n        w._long = ew;\n        w._lat  = ns;\n        [[WaveHelper trace] addPoint:w];\n    }\n}\n\n- (void)setOnNoFix:(int)onNoFix {\n    _onNoFix=onNoFix;\n}\n\n- (NSDate*) lastUpdate {\n    return _lastUpdate;\n}\n\n#pragma mark -\n\nbool check_sum(char *s, char h, char l) {\n  char checksum;\n  unsigned char ref;      /* must be unsigned */\n\n#ifdef PARANOIA\n  if(!s)\n    return NO;\n  if(!*s)\n    return NO;\n#endif\n\n  checksum = *s++;\n  while(*s && *s !='*')\n    checksum ^= *s++;\n\n#ifdef PARANOIA\n  if(!isxdigit(h))\n    return NO;\n  if(!isxdigit(l))\n    return NO;\n  h = (char)toupper(h);\n  l = (char)toupper(l);\n#endif\n\n  ref =  ((h >= 'A') ? (h -'A' + 10):(h - '0'));\n  ref <<= 4;\n  ref &= ((l >= 'A') ? (l -'A' + 10):(l - '0'));\n\n  if((char)ref == checksum)\n    return YES;             /* ckecksum OK */\n  \n  return NO;              /* checksum error */\n}\n\nint ss(char* inp, char* outp) {\n    int x=0;\n    \n    while(true) {\n        if (inp[x]==0) return -1;\n        if (inp[x]=='\\n') {\n            outp[x]=0;\n            return x;\n        }\n        outp[x]=inp[x];\n        x++;\n    }\n    \n    return x;\n}\n\n- (bool)gps_parse:(int) fd {\n    int len, valid, x=0;\n    static int q = 0;\n    char cvalid;\n    static char gpsin[MAX_GPSBUF_LEN];\n    char gpsbuf[MAX_GPSBUF_LEN];\n    int ewh, nsh;\n\tint veldir,numsat;\n\tfloat velkt,hdop;\n\tfloat timeinterval=-1;\n\tfloat displacement;\n    struct _position ns, ew, elev;\n    bool updated;\n    NSDate *date;\n    NSAutoreleasePool* subpool = [[NSAutoreleasePool alloc] init];\n\n    if (_debugEnabled) NSLog(@\"GPS read data\");\n    if (q>=1024) q = 0; //just in case something went wrong\n    \n    if((len = read(fd, &gpsin[q], MAX_GPSBUF_LEN-q-1)) < 0) return NO;\n    if (len == 0) return YES;\n    \n    if (_debugEnabled) NSLog(@\"GPS read data returned.\");\n    [self setStatus:nil];\n    _linesRead++;\n    \n    gpsin[q+len]=0;\n    updated = NO;\n    elev.coordinates = -10000.0;\n\tvelkt = -1.0;\n\tnumsat = -1;\n\thdop = 100;\n    \n    while (ss(&gpsin[x],gpsbuf)>0) {\n        if (_debugEnabled) NSLog(@\"GPS record: %s\", gpsbuf);//uncommented\n        if(_tripmateMode && (!strncmp(gpsbuf, \"ASTRAL\", 6))) {\n            write(fd, \"ASTRAL\\r\", 7);\n        } else if(strncmp(gpsbuf, \"$GPGGA\", 6) == 0) {  //gpsbuf contains GPS fixed data (almost everything poss)\n            if (sscanf(gpsbuf, \"%*[^,],%*f,%2d%f,%c,%3d%f,%c,%d,%d,%f,%f\",\n\t\t&nsh, &ns.coordinates, &ns.dir,\n                &ewh, &ew.coordinates, &ew.dir,\n\t        &valid, &numsat, &hdop, &elev.coordinates)>=7) { // this probably should be == 10 not >= 7  more testing\n                \t\t\n                if (valid) _reliable = YES;\n                else _reliable = NO;\n                \n                if (_debugEnabled) NSLog(@\"GPS data updated.\");\n                updated = YES;\n            }\n        } else if(strncmp(gpsbuf, \"$GPRMC\", 6) == 0) {  //gpsbuf contains Recommended minimum specific GPS/TRANSIT data !!does not include elevation\n            if (sscanf(gpsbuf, \"%*[^,],%*f,%c,%2d%f,%c,%3d%f,%c,%f,%d,\",\n                &cvalid, &nsh, &ns.coordinates, &ns.dir,\n                &ewh, &ew.coordinates, &ew.dir, &velkt, &veldir)==9) {\n            \n                if (cvalid == 'A') _reliable = YES;\n                else _reliable = NO;\n                \n                if (_debugEnabled) NSLog(@\"GPS data updated.\");  \n                updated = YES;\n            }\n        } else if(strncmp(gpsbuf, \"$GPGLL\", 6) == 0) {  //gbsbuf contains Geographical postiion, latitude and longitude only  !!does not include elevation\n            if (sscanf(gpsbuf, \"%*[^,],%2d%f,%c,%3d%f,%c,%*f,%c\",\n                &nsh, &ns.coordinates, &ns.dir,\n                &ewh, &ew.coordinates, &ew.dir, &cvalid)==7) {\n            \n                if (cvalid == 'A') _reliable = YES;\n                else _reliable = NO;\n                \n                if (_debugEnabled) NSLog(@\"GPS data updated.\");  \n                updated = YES;\n            }\n        }\n        \n        x+=strlen(gpsbuf)+1;\n    }\n    \n    q+=len-x;\n    memcpy(gpsbuf,&gpsin[x],q);\n    memcpy(gpsin,gpsbuf,q);\n    if (q>80) q=0;\n    \n\tdate = [[NSDate alloc] init];\n    \n\tif (updated) {\n        if (_reliable) {\n            if (([_lastUpdate timeIntervalSinceDate:_lastAdd]>_traceInterval) && (_traceInterval != 100)) {\n                waypoint w;\n                w._lat  = _ns.coordinates * ((_ns.dir=='N') ? 1.0 : -1.0);\n                w._long = _ew.coordinates * ((_ew.dir=='E') ? 1.0 : -1.0);\n                if ([[WaveHelper trace] addPoint:w]) [WaveHelper secureReplace:&_lastAdd withObject:date];\n            }\n        } else {\n            [[WaveHelper trace] cut];\n        }\n\t\ttimeinterval = [date timeIntervalSinceDate:_lastUpdate];\n        [WaveHelper secureReplace:&_lastUpdate withObject:date];\n\n        if ((_reliable)||(_onNoFix==0)) {\n            if (ns.dir != 'S') _ns.dir = 'N';\n            else _ns.dir = 'S';\n            \n            if (ew.dir != 'W') _ew.dir = 'E';\n            else _ew.dir = 'W';\n            \n            _ns.coordinates   = nsh + ns.coordinates / 60.0;\n            _ew.coordinates   = ewh + ew.coordinates / 60.0;\n            if (elev.coordinates > -10000.00) _elev.coordinates = elev.coordinates;\n\t\t\t\n            if (velkt > -1.0) {\n\t\t\t\tif ((velkt > 0) && (_velkt==0)) {\n\t\t\t\t\t_peakvel = 0;\n\t\t\t\t\t_sectordist = 0;\n\t\t\t\t\t_sectortime = 0;\n\t\t\t\t\t[WaveHelper secureReplace:&_sectorStart withObject:date];\n\t\t\t\t} else if ((velkt > 0) || (_velkt > 0)) {\n\t\t\t\t\t// update distances only if we're moving (or just stopped)\n\t\t\t\t\tdisplacement = (velkt + _velkt)*timeinterval/7200;\n\t\t\t\t\t_sectordist += displacement;\n\t\t\t\t\t_sectortime += timeinterval;\n\t\t\t\t\t_totaldist += displacement;\n\t\t\t\t}\n                _velkt = velkt;\n                _veldir = veldir;\n\t\t\t\tif (velkt > _peakvel) _peakvel = velkt;\n\t\t\t\tif (velkt > _maxvel) _maxvel = velkt;\n\t\t\t}\n            \n            if (numsat > -1) {\n                _numsat = numsat;\n                _hdop = hdop;\n            }\n        } else if(_onNoFix==2) {\n            _ns.dir = 'N';\n            _ew.dir = 'E';\n            \n            _elev.coordinates = 0;\n            _ns.coordinates = 0;\n            _ew.coordinates = 0;\n            _velkt = 0;\n        }\n    }\n    \n    [subpool release];\n\t[date release];\n    \n    return YES;\n}\n\n- (bool)gpsd_parse:(int) fd {\n    int len, valid, numsat, veldir;\n    char gpsbuf[MAX_GPSBUF_LEN];\n    double ns, ew, elev;\n\tfloat velkt,hdop,fveldir;\n\tfloat timeinterval=-1;\n\tfloat displacement;\n    NSDate *date;\n    NSAutoreleasePool* subpool = [[NSAutoreleasePool alloc] init];\n\n    if (_debugEnabled) NSLog(@\"GPSd write command\");\n    \n    if (write(fd, \"PAMVTQ\\r\\n\", 8) < 8) {\n        NSLog(@\"GPSd write failed\");\n        return NO;\n    }\n    \n    if((len = read(fd, &gpsbuf[0], MAX_GPSBUF_LEN)) < 0) {\n        NSLog(@\"GPSd read failed\");\n        return NO;\n    }\n    if (len == 0) return YES;\n    \n    if (_debugEnabled) NSLog(@\"GPSd read data returned.\");\n    [self setStatus:nil];\n    _linesRead++;\n    \n    gpsbuf[0+len]=0;\n \tnumsat = -1;\n\thdop = 100;\n   \n\tdate = [[NSDate alloc] init];\n\n\tif (sscanf(gpsbuf, \"GPSD,P=%lg %lg,A=%lg,M=%d,V=%f,T=%f,Q=%d %*f %f\",\n        &ns, &ew, &elev, &valid, &velkt, &fveldir, &numsat, &hdop) >=6) {\n                        \n        if (valid >= 2) _reliable = YES;\n        else _reliable = NO;\n        \n        if (_debugEnabled) NSLog(@\"GPSd data updated.\");\n\t\t\n\t\tif (_reliable) {\n            if (([_lastUpdate timeIntervalSinceDate:_lastAdd]>_traceInterval) && (_traceInterval != 100)) {\n                waypoint w;\n                w._lat  = _ns.coordinates * ((_ns.dir=='N') ? 1.0 : -1.0);\n                w._long = _ew.coordinates * ((_ew.dir=='E') ? 1.0 : -1.0);\n                if ([[WaveHelper trace] addPoint:w]) [WaveHelper secureReplace:&_lastAdd withObject:date];\n            }\n        } else {\n            [[WaveHelper trace] cut];\n        }\n\t\ttimeinterval = [date timeIntervalSinceDate:_lastUpdate];\n        [WaveHelper secureReplace:&_lastUpdate withObject:date];\n\n\n        if ((_reliable)||(_onNoFix==0)) {\n            if (ns >= 0) _ns.dir = 'N';\n            else _ns.dir = 'S';\n            \n            if (ew >= 0) _ew.dir = 'E';\n            else _ew.dir = 'W';\n            \n            _ns.coordinates   = fabs(ns);\n            _ew.coordinates   = fabs(ew);\n            _elev.coordinates = elev;\n\t\t\tif ((velkt > 0) && (_velkt==0)) {\n\t\t\t\t_peakvel = 0;\n\t\t\t\t_sectordist = 0;\n\t\t\t\t_sectortime = 0;\n\t\t\t\t[WaveHelper secureReplace:&_sectorStart withObject:date];\n\t\t\t} else if ((velkt > 0) || (_velkt > 0)) {\n\t\t\t\t// update distances only if we're moving (or just stopped)\n\t\t\t\tdisplacement = (velkt + _velkt)*timeinterval/7200;\n\t\t\t\t_sectordist += displacement;\n\t\t\t\t_sectortime += timeinterval;\n\t\t\t\t_totaldist += displacement;\n\t\t\t}\n\t\t\t_velkt = velkt;\n\t\t\tveldir = (int)fveldir;\n\t\t\t_veldir = veldir;\n\t\t\tif (velkt > _peakvel) _peakvel = velkt;\n\t\t\tif (velkt > _maxvel) _maxvel = velkt;\n\n\t\t\tif (numsat > -1) {\n\t\t\t\t_numsat = numsat;\n\t\t\t\t_hdop = hdop;\n\t\t\t}\n\t\t} else if(_onNoFix==2) {\n            _ns.dir = 'N';\n            _ew.dir = 'E';\n            \n            _elev.coordinates = 0;\n            _ns.coordinates = 0;\n            _ew.coordinates = 0;\n            _velkt = 0;\n        }\n    } else {\n        NSLog(@\"GPSd parsing failure\");\n    }\n    \n    [subpool release];\n\t[date release];\n    \n    return YES;\n}\n\n- (void) continousParse:(int) fd {\n    NSDate *date;\n    unsigned int i = 0;\n    NSAutoreleasePool* subpool;\n\t\n    while (_gpsShallRun && [self gps_parse:fd]) {\n\t\tsubpool = [[NSAutoreleasePool alloc] init];\n        //actually once a sec should be enough, but sometimes we dont get any information. so do it more often.\n        if ((i++ % 10 == 0) && (_status == Nil))\n            [[NSNotificationCenter defaultCenter] postNotificationName:KisMACGPSStatusChanged object:[self status]];\n        date = [[NSDate alloc] initWithTimeIntervalSinceNow:0.1];\n        [NSThread sleepUntilDate:date];\n        [date release];\n\t\t[subpool release];\n    }\n}\n\n- (void) continousParseGPSd:(int) fd {\n    NSDate *date;\n    unsigned int i = 0;\n\tNSAutoreleasePool* subpool;\n\n    while (_gpsShallRun && [self gpsd_parse:fd]) {\n\t\tsubpool = [[NSAutoreleasePool alloc] init];\n        if ((i++ % 2 == 0) && (_status == Nil))\n            [[NSNotificationCenter defaultCenter] postNotificationName:KisMACGPSStatusChanged object:[self status]];\n        date = [[NSDate alloc] initWithTimeIntervalSinceNow:0.5];\n        [NSThread sleepUntilDate:date];\n        [date release];\n\t\t[subpool release];\n    }\n}\n\n- (void)gpsThreadSerial:(id)object {\n    NSAutoreleasePool* subpool = [[NSAutoreleasePool alloc] init];\n    int     handshake;\n    struct  termios backup;\n\n    _gpsShallRun = NO;\n    \n    if ([_gpsLock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:10]]) {\n        _gpsThreadUp = YES;\n        _gpsShallRun = YES;\n        [_lastUpdate release];\n        _lastUpdate = nil;\n        [_sectorStart release];\n        _sectorStart = nil;\n        \n        [self setStatus:NSLocalizedString(@\"GPS subsystem starting up.\", @\"GPS status\")];\n\n        //NSLog(@\"Starting GPS device\");\n        if((_serialFD = open([_gpsDevice cString], O_RDWR | O_NOCTTY | O_NONBLOCK )) < 0) {\n            NSLog(@\"error: unable to open gps device: %s\", strerror(errno));\n            [self setStatus:NSLocalizedString(@\"Could not open GPS.\", @\"GPS status\")];\n        } else if(!isatty(_serialFD)) {\n            NSLog(@\"error: specified gps device is not a tty: %s\", strerror(errno));\n        } else if (ioctl(_serialFD, TIOCEXCL) == -1) {\n            NSLog(@\"error: could not set exclusive flag: %s\", strerror(errno));\n        } else if (fcntl(_serialFD, F_SETFL, 0) == -1) {\n            NSLog(@\"error: clearing O_NONBLOCK: %s(%d).\\n\", strerror(errno), errno);\n        } else if(tcgetattr(_serialFD, &backup) != 0) {\n            NSLog(@\"error: unable to set attributes for gps device: %s\", strerror(errno));\n        } else if(ioctl(_serialFD, TIOCGETA, &ttyset) < 0) {\n            NSLog(@\"error: unable to ioctl gps device: %s\", strerror(errno));\n        } else {\n            //NSLog(@\"GPS device is open\");\n            ttyset.c_ispeed = B4800;\n            ttyset.c_ospeed = B4800;\n            \n            ttyset.c_cflag |=       CRTSCTS;    // hadware flow on\n            ttyset.c_cflag &=       ~PARENB;    // no parity\n            ttyset.c_cflag &=       ~CSTOPB;    // one stopbit\n            ttyset.c_cflag &=       CSIZE;\n            ttyset.c_cflag |=       CS8;        // 8N1\n            ttyset.c_cflag |=       (CLOCAL | CREAD); //enable Localmode, receiver\n            ttyset.c_cc[VMIN] =     20;         // set min read chars if 0  VTIME takes over\n            ttyset.c_cc[VTIME] =    10;         // wait x ms for charakter\n\n            //options.c_cflag &= ~ ICANON; // canonical input \n            ttyset.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);\n\n            \n            if(ioctl(_serialFD, TIOCSETAF, &ttyset) < 0) {\n                NSLog(@\"error: unable to ioctl gps device: %s\", strerror(errno));\n            } else {\n                if (ioctl(_serialFD, TIOCSDTR) == -1) { // Assert Data Terminal Ready (DTR)\n                    NSLog(@\"Error asserting DTR - %s(%d).\\n\", strerror(errno), errno);\n                }\n                \n                if (ioctl(_serialFD, TIOCCDTR) == -1) { // Clear Data Terminal Ready (DTR) \n                    NSLog(@\"Error clearing DTR - %s(%d).\\n\", strerror(errno), errno);\n                }\n                \n                handshake = TIOCM_DTR | TIOCM_RTS | TIOCM_CTS | TIOCM_DSR;\n                if (ioctl(_serialFD, TIOCMSET, &handshake) == -1) { // Set the modem lines depending on the bits set in handshake\n                    NSLog(@\"Error setting handshake lines - %s(%d).\\n\", strerror(errno), errno);\n                }\n                \n                if (ioctl(_serialFD, TIOCMGET, &handshake) == -1) { // Store the state of the modem lines in handshake\n                    NSLog(@\"Error getting handshake lines - %s(%d).\\n\", strerror(errno), errno);\n                }\n\n                NSLog(@\"GPS started successfully in serial mode\\n\");\n                [self setStatus:NSLocalizedString(@\"GPS started in serial mode.\", @\"GPS status\")];\n\n                [self continousParse:_serialFD];\n            }\n            \n            if (_serialFD) close(_serialFD);\n            [self setStatus:NSLocalizedString(@\"GPS device closed.\", @\"GPS status\")];\n        }    \n\n        [_gpsLock unlock];\n        _gpsThreadUp = NO;\n    } else {\n        NSLog(@\"GPS LOCKING FAILURE!\");\n    }\n    \n    [subpool release];\n    return;\n}\n\n- (void)gpsThreadGPSd:(id)object {\n    int sockd;\n    struct sockaddr_in serv_name;\n    int status;\n    struct hostent *hp;\n    UInt32 ip;\n    NSUserDefaults *sets;\n    const char *hostname;\n    NSAutoreleasePool* subpool = [[NSAutoreleasePool alloc] init];\n    \n    _gpsShallRun = NO;\n    \n    if ([_gpsLock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:10]]) {\n        _gpsThreadUp = YES;\n        _gpsShallRun = YES;\n        [_lastUpdate release];\n        _lastUpdate = nil;\n        [_sectorStart release];\n        _sectorStart = nil;\n        \n        [self setStatus:NSLocalizedString(@\"Starting GPS in GPSd mode.\", @\"GPS status\")];\n\n        sets = [NSUserDefaults standardUserDefaults];\n        \n        sockd  = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockd == -1) {\n            NSLog(@\"Socket creation failed!\");\n            goto err;\n        }\n        \n        hostname = [[sets objectForKey:@\"GPSDaemonHost\"] cString];\n        \n        if (inet_addr(hostname) != INADDR_NONE) {\n            ip = inet_addr(hostname);\n        } else {\n            hp = gethostbyname(hostname);\n            if (hp == NULL) {\n                NSLog(@\"Could not resolve %s\", hostname);\n                goto err;\n            }\n            ip = *(int *)hp->h_addr_list[0];\n        }\n        \n        /* server address */\n        serv_name.sin_addr.s_addr = ip;\n        serv_name.sin_family = AF_INET;\n        serv_name.sin_port = htons([sets integerForKey:@\"GPSDaemonPort\"]);\n\n        NSLog(@\"Connecting to gpsd (%s)\",inet_ntoa(serv_name.sin_addr));\n\n        /* connect to the server */\n        status = connect(sockd, (struct sockaddr*)&serv_name, sizeof(serv_name));\n        \n        if (status == -1) {\n            NSLog(@\"Could not connect to %s port %d\", hostname, [sets integerForKey:@\"GPSDaemonPort\"]);\n            goto err;\n        }\n\n        NSLog(@\"GPS started successfully in GPSd mode.\\n\");\n        [self setStatus:NSLocalizedString(@\"GPS started in GPSd mode.\", @\"GPS status\")];\n\n        [self continousParseGPSd: sockd];\n        close(sockd);\n\n        [self setStatus:NSLocalizedString(@\"GPSd connection terminated.\", @\"GPS status\")];\n    err:\n        [_gpsLock unlock];\n        _gpsThreadUp = NO;\n    } else {\n        NSLog(@\"GPS LOCKING FAILURE!\");\n    }\n\n    [subpool release];\n    return;\n}\n\n#pragma mark -\n\n- (void)writeDebugOutput:(BOOL)enable {\n    _debugEnabled = enable;\n}\n\n#pragma mark -\n\n- (void)stop {\n    int fd;\n    _gpsShallRun=NO;\n\n    [self setStatus:NSLocalizedString(@\"Trying to terminate GPS subsystem.\", @\"GPS status\")];\n    \n    if ([_gpsLock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:0.5]]) {\n        [_gpsLock unlock];\n    } else {\n        //kill the file descriptor if cannot obtain a lock\n        if (_serialFD) {\n            fd = _serialFD;\n            _serialFD = 0;\n            close(fd);\n        }\n    }\n}\n\n- (void) dealloc {\n    [WaveHelper secureRelease:&_status];\n    _gpsShallRun=NO;\n    [_gpsLock release];\n    [_gpsDevice release];\n    [_lastAdd release];\n    [super dealloc];\n}\n\n@end\n";
		rLen = 29083;
		rLoc = 0;
		rType = 0;
		vrLen = 719;
		vrLoc = 28364;
	};
	00766A270784506900A30713 = {
		fRef = 0035341C06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = sendFrame;
		rLen = 9;
		rLoc = 4449;
		rType = 0;
		vrLen = 835;
		vrLoc = 4068;
	};
	00766A2A0784506900A30713 = {
		fRef = 007665910784504B00A30713;
		isa = PBXTextBookmark;
		name = "/*\n        \n        File:\t\t\tGPSController.m\n        Program:\t\tKisMAC\n\tAuthor:\t\t\tMichael Rossberg\n                                mick@binaervarianz.de\n\tDescription:\t\tKisMAC is a wireless stumbler for MacOS X.\n                \n        This file is part of KisMAC.\n        \n        Parts of this file are based on bsd airtools by h1kari.\n\n    KisMAC is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    KisMAC is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with KisMAC; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\n#import \"GPSController.h\"\n#import \"WaveHelper.h\"\n#import \"KisMACNotifications.h\"\n#import \"Trace.h\"\n\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/uio.h>\n#include <sys/vnode.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <string.h>\n#include <errno.h>\n\n#include <sys/termios.h>\n\nstruct termios ttyset;\n\n#define MAX_GPSBUF_LEN 1024\n#define VELOCITY_UNIT \"km/h\"\n#define VELOCITY_CONVERSION 1.852\n#define DISTANCE_UNIT \"km\"\n\n@interface GPSController(PrivateExtension) \n    - (void)setStatus:(NSString*)status;\n@end\n\n@implementation GPSController\n\n- (id)init {\n    _gpsLock = [[NSLock alloc] init];\n    _gpsThreadUp    = NO;\n    _gpsShallRun    = NO;\n    _debugEnabled   = NO;\n    _lastAdd        = [[NSDate date] retain];\n    _linesRead      = 0;\n\n    [self setStatus:NSLocalizedString(@\"GPS subsystem initialized but not running.\", @\"GPS status\")];\n\n    return self;\n}\n\n- (bool)startForDevice:(NSString*) device {\n    _reliable = NO;\n    _ns.dir = 'N';\n    _ns.coordinates = 0;\n    _ew.dir = 'E';\n    _ew.coordinates = 0;\n    _elev.coordinates = 0;\n    _elev.dir = 'm';\n    _velkt = 0;\n\t_peakvel = 0;\n    _veldir = -1;\n    _numsat = -1;\n    _hdop = 100;\n\t_sectordist = 0;\n\t_sectortime = 0;\n\t_totaldist = 0;\n\n    [self stop];\n    \n    [WaveHelper secureReplace:&_gpsDevice withObject:device];\n    [WaveHelper secureRelease:&_lastUpdate];\n    [WaveHelper secureRelease:&_sectorStart];\n    \n    if ([_gpsDevice length]==0) {\n        NSLog(@\"GPS integration disabled\");\n        [self setStatus:NSLocalizedString(@\"GPS subsystem disabled.\", @\"GPS status\")];\n        return NO;\n    }\n\n    [self setStatus:NSLocalizedString(@\"Starting GPS subsystem.\", @\"GPS status\")];\n    \n    if ([_gpsDevice isEqualToString:@\"GPSd\"]) [NSThread detachNewThreadSelector:@selector(gpsThreadGPSd:) toTarget:self withObject:Nil];\n    else [NSThread detachNewThreadSelector:@selector(gpsThreadSerial:) toTarget:self withObject:Nil];\n    return YES;\n}\n\n#pragma mark -\n\n- (bool)reliable {\n    return _reliable;\n}\n\n- (bool)gpsRunning {\n    return _gpsThreadUp;\n}\n\n- (NSString*) NSCoord {\n    if (_ns.coordinates==0) return nil;\n    return [NSString stringWithFormat:@\"%f%c\",_ns.coordinates, _ns.dir];\n}\n\n- (NSString*) EWCoord {\n    if (_ew.coordinates==0) return nil;\n    return [NSString stringWithFormat:@\"%f%c\",_ew.coordinates, _ew.dir];\n}\n\n- (NSString*) ElevCoord {\n    if (_elev.coordinates==0) return [NSString stringWithFormat:@\"No Elevation Data\"];\n    //NSLog([NSString stringWithFormat:@\"%f\",_elev.coordinates]);\n    return [NSString stringWithFormat:@\"%.1f %c/%.1f ft\",_elev.coordinates, _elev.dir, (_elev.coordinates * 3.2808399)]; //don't know if formatting stuff is correct\n}\n\n- (NSString*) VelKt {\n\tfloat velconv,peakconv,maxconv;\n\tvelconv = _velkt * VELOCITY_CONVERSION;\n\tpeakconv = _peakvel * VELOCITY_CONVERSION;\n\tmaxconv = _maxvel * VELOCITY_CONVERSION;\n\tif (_velkt==_maxvel) {\n\t\tif (_veldir==-1) return [NSString stringWithFormat:@\"%.1f %s (%.1f kt) [MAX]\",velconv,VELOCITY_UNIT,_velkt];\n\t\treturn [NSString stringWithFormat:@\"%.1f %s (%.1f kt) [MAX]\\nTrack: %d T\",velconv,VELOCITY_UNIT,_velkt,_veldir];\n\t} else if (_velkt==_peakvel) {\n\t\tif (_veldir==-1) return [NSString stringWithFormat:@\"%.1f %s (%.1f kt) [PEAK]\",velconv,VELOCITY_UNIT,_velkt];\n\t\treturn [NSString stringWithFormat:@\"%.1f %s (%.1f kt) [PEAK]\\nTrack: %d T\",velconv,VELOCITY_UNIT,_velkt,_veldir];\n\t} else {\n\t\tif (_veldir==-1) return [NSString stringWithFormat:@\"%.1f %s (%.1f kt) [peak: %.1f, max: %.1f]\",velconv,VELOCITY_UNIT,_velkt,peakconv,maxconv];\n\t\treturn [NSString stringWithFormat:@\"%.1f %s (%.1f kt) [peak: %.1f, max: %.1f]\\nTrack: %d T\",velconv,VELOCITY_UNIT,_velkt,peakconv,maxconv,_veldir];\n\t}\n}\n\n- (NSString*) DistStats {\n\tint sectortime;\n\tint sterror=0;\n\tfloat timeinterval;\n\tsectortime = (int)_sectortime;\n\n\tif (_sectorStart && (sectortime > 0)) {\n\t\ttimeinterval = [[NSDate date] timeIntervalSinceDate:_sectorStart];\n\t\tsterror = sectortime - (int)timeinterval;\n\t\t// remove negative error that develops after stopping\n\t\tif ((_velkt == 0) && (sterror < 0)) sterror = 0;\n\t}\n\t\n\tif (sterror == 0) {\n\t\tif (sectortime > 3600) return [NSString stringWithFormat:@\"Sector: %.1f %s (%.1f nm) in %d:%02d:%02d (avg: %.1f %s)\\nTotal: %.1f %s (%.1f nm)\",(_sectordist * VELOCITY_CONVERSION),DISTANCE_UNIT,_sectordist,(sectortime/3600),(sectortime%3600/60),(sectortime%60),(3600 * _sectordist * VELOCITY_CONVERSION)/_sectortime,VELOCITY_UNIT,(_totaldist * VELOCITY_CONVERSION),DISTANCE_UNIT,_totaldist];\n\t\telse if (sectortime > 60) return [NSString stringWithFormat:@\"Sector: %.1f %s (%.1f nm) in %d:%02d (avg: %.1f %s)\\nTotal: %.1f %s (%.1f nm)\",(_sectordist * VELOCITY_CONVERSION),DISTANCE_UNIT,_sectordist,(sectortime/60),(sectortime%60),(3600 * _sectordist * VELOCITY_CONVERSION)/_sectortime,VELOCITY_UNIT,(_totaldist * VELOCITY_CONVERSION),DISTANCE_UNIT,_totaldist];\n\t\telse if (sectortime > 0) return [NSString stringWithFormat:@\"Sector: %.1f %s (%.1f nm) in %d seconds (avg: %.1f %s)\\nTotal: %.1f %s (%.1f nm)\",(_sectordist * VELOCITY_CONVERSION),DISTANCE_UNIT,_sectordist,sectortime,(3600 * _sectordist * VELOCITY_CONVERSION)/_sectortime,VELOCITY_UNIT,(_totaldist * VELOCITY_CONVERSION),DISTANCE_UNIT,_totaldist];\n\t\telse return [NSString stringWithFormat:@\"Total: %.1f %s (%.1f nm)\",(_totaldist * VELOCITY_CONVERSION),DISTANCE_UNIT,_totaldist];\n\t} else {\n\t\tif (sectortime > 3600) return [NSString stringWithFormat:@\"Sector: %.1f %s (%.1f nm) in %d:%02d:%02d [ERROR: %ds] (avg: %.1f %s)\\nTotal: %.1f %s (%.1f nm)\",(_sectordist * VELOCITY_CONVERSION),DISTANCE_UNIT,_sectordist,(sectortime/3600),(sectortime%3600/60),(sectortime%60),sterror,(3600 * _sectordist * VELOCITY_CONVERSION)/_sectortime,VELOCITY_UNIT,(_totaldist * VELOCITY_CONVERSION),DISTANCE_UNIT,_totaldist];\n\t\telse if (sectortime > 60) return [NSString stringWithFormat:@\"Sector: %.1f %s (%.1f nm) in %d:%02d [ERROR: %ds] (avg: %.1f %s)\\nTotal: %.1f %s (%.1f nm)\",(_sectordist * VELOCITY_CONVERSION),DISTANCE_UNIT,_sectordist,(sectortime/60),(sectortime%60),sterror,(3600 * _sectordist * VELOCITY_CONVERSION)/_sectortime,VELOCITY_UNIT,(_totaldist * VELOCITY_CONVERSION),DISTANCE_UNIT,_totaldist];\n\t\telse return [NSString stringWithFormat:@\"Sector: %.1f %s (%.1f nm) in %d seconds [ERROR: %ds] (avg: %.1f %s)\\nTotal: %.1f %s (%.1f nm)\",(_sectordist * VELOCITY_CONVERSION),DISTANCE_UNIT,_sectordist,sectortime,sterror,(3600 * _sectordist * VELOCITY_CONVERSION)/_sectortime,VELOCITY_UNIT,(_totaldist * VELOCITY_CONVERSION),DISTANCE_UNIT,_totaldist];\n\t}\n}\n\n- (NSString*) QualData {\n\tif (_numsat==-1) return [NSString stringWithFormat:@\"\"];\n\tif (_hdop>=50 || _hdop==0) return [NSString stringWithFormat:@\" (%d sats)\",_numsat];\n\treturn [NSString stringWithFormat:@\" (%d sats, HDOP %.1f)\",_numsat,_hdop];\n}\n\n- (NSString*)status {\n    if (_status) return _status;\n    \n    if (_lastUpdate)\n        if (_elev.coordinates) \n            if ((_velkt || _maxvel) && _reliable) // only report velocity if we're sure\n                return [NSString stringWithFormat:@\"%@: %@ %@\\n%@: %@\\n%@: %@\\n%@\\n%@: %@%@\", \n                        NSLocalizedString(@\"Position\", \"GPS status string.\"), \n                        [self NSCoord],[self EWCoord],\n                        NSLocalizedString(@\"Elevation\", \"GPS status string.\"), \n                        [self ElevCoord],\n                        NSLocalizedString(@\"Velocity\", \"GPS status string.\"), \n                        [self VelKt],[self DistStats],\n\t\t\t\t\t\tNSLocalizedString(@\"Time\", \"GPS status string.\"), \n\t\t\t\t\t\t[self lastUpdate],[self QualData]];\n            else\n                return [NSString stringWithFormat:@\"%@: %@ %@\\n%@: %@\\n%@: %@%@%@\", \n                        NSLocalizedString(@\"Position\", \"GPS status string.\"), \n                        [self NSCoord],[self EWCoord],\n                        NSLocalizedString(@\"Elevation\", \"GPS status string.\"), \n                        [self ElevCoord],\n\t\t\t\t\t\tNSLocalizedString(@\"Time\", \"GPS status string.\"), \n\t\t\t\t\t\t[self lastUpdate],\n                        _reliable ? @\"\" : NSLocalizedString(@\" -- NO FIX\", \"GPS status string. Needs leading space\"),\n                        [self QualData]];\n        else\n            return [NSString stringWithFormat:@\"%@: %@ %@\\n%@%@\", \n                NSLocalizedString(@\"Position\", \"GPS status string.\"), \n                [self NSCoord],[self EWCoord],\n                [self lastUpdate],\n                _reliable ? @\"\" : NSLocalizedString(@\" -- NO FIX\", \"GPS status string. Needs leading space\"),\n\t\t\t\t[self QualData]];\n\n    else if ([(NSString*)[[NSUserDefaults standardUserDefaults] objectForKey:@\"GPSDevice\"] length]) {\n        if (_gpsThreadUp) return NSLocalizedString(@\"GPS subsystem works, but there is no data.\\nIf you are using gpsd, there may be no GPS connected.\\nOtherwise, your GPS is probably connected but not yet reporting a position.\", \"GPS status string\");\n        else  return NSLocalizedString(@\"GPS not working\", \"LONG GPS status string with informations howto debug\");\n            //@\"GPS subsystem is not working. See log file for more details.\"\n    } else return NSLocalizedString(@\"GPS disabled\", \"LONG GPS status string with informations where to enable\");\n            //@\"GPS subsystem is disabled. You have to select a device in the preferences window.\"\n}\n\n- (void)setStatus:(NSString*)status {\n    [WaveHelper secureReplace:&_status withObject:status];\n    [[NSNotificationCenter defaultCenter] postNotificationName:KisMACGPSStatusChanged object:_status];\n}\n\n- (waypoint) currentPoint {\n    waypoint w;\n    \n    w._lat =_ns.coordinates * ((_ns.dir=='N') ? 1.0 : -1.0);\n    w._long=_ew.coordinates * ((_ew.dir=='E') ? 1.0 : -1.0);\n    w._elevation=_elev.coordinates;\n    \n    return w;\n}\n\n- (void) resetTrace {\n    [[WaveHelper trace] setTrace:nil];\n}\n\n- (void)setTraceInterval:(int)interval {\n    _traceInterval = interval;\n}\n- (void)setTripmateMode:(bool)mode {\n    _tripmateMode = mode;\n}\n\n- (void) setCurrentPointNS:(double)ns EW:(double)ew ELV:(double)elv{  //need to add elevation support here\n    waypoint w;\n    _ns.dir = (ns<0 ? 'S' : 'N');\n    _ew.dir = (ew<0 ? 'W' : 'E');\n    \n    _ns.coordinates = fabs(ns);\n    _ew.coordinates = fabs(ew); \n    \n    [WaveHelper secureReplace:&_lastUpdate withObject:[NSDate date]];\n    [WaveHelper secureReplace:&_lastAdd withObject:[NSDate date]];\n    \n    if (abs(ns)>=0 && abs(ns)<=90 && abs(ew)>=0 && abs(ew)<=180) {\n        w._long = ew;\n        w._lat  = ns;\n        [[WaveHelper trace] addPoint:w];\n    }\n}\n\n- (void)setOnNoFix:(int)onNoFix {\n    _onNoFix=onNoFix;\n}\n\n- (NSDate*) lastUpdate {\n    return _lastUpdate;\n}\n\n#pragma mark -\n\nbool check_sum(char *s, char h, char l) {\n  char checksum;\n  unsigned char ref;      /* must be unsigned */\n\n#ifdef PARANOIA\n  if(!s)\n    return NO;\n  if(!*s)\n    return NO;\n#endif\n\n  checksum = *s++;\n  while(*s && *s !='*')\n    checksum ^= *s++;\n\n#ifdef PARANOIA\n  if(!isxdigit(h))\n    return NO;\n  if(!isxdigit(l))\n    return NO;\n  h = (char)toupper(h);\n  l = (char)toupper(l);\n#endif\n\n  ref =  ((h >= 'A') ? (h -'A' + 10):(h - '0'));\n  ref <<= 4;\n  ref &= ((l >= 'A') ? (l -'A' + 10):(l - '0'));\n\n  if((char)ref == checksum)\n    return YES;             /* ckecksum OK */\n  \n  return NO;              /* checksum error */\n}\n\nint ss(char* inp, char* outp) {\n    int x=0;\n    \n    while(true) {\n        if (inp[x]==0) return -1;\n        if (inp[x]=='\\n') {\n            outp[x]=0;\n            return x;\n        }\n        outp[x]=inp[x];\n        x++;\n    }\n    \n    return x;\n}\n\n- (bool)gps_parse:(int) fd {\n    int len, valid, x=0;\n    static int q = 0;\n    char cvalid;\n    static char gpsin[MAX_GPSBUF_LEN];\n    char gpsbuf[MAX_GPSBUF_LEN];\n    int ewh, nsh;\n\tint veldir,numsat;\n\tfloat velkt,hdop;\n\tfloat timeinterval=-1;\n\tfloat displacement;\n    struct _position ns, ew, elev;\n    bool updated;\n    NSDate *date;\n    NSAutoreleasePool* subpool = [[NSAutoreleasePool alloc] init];\n\n    if (_debugEnabled) NSLog(@\"GPS read data\");\n    if (q>=1024) q = 0; //just in case something went wrong\n    \n    if((len = read(fd, &gpsin[q], MAX_GPSBUF_LEN-q-1)) < 0) return NO;\n    if (len == 0) return YES;\n    \n    if (_debugEnabled) NSLog(@\"GPS read data returned.\");\n    [self setStatus:nil];\n    _linesRead++;\n    \n    gpsin[q+len]=0;\n    updated = NO;\n    elev.coordinates = -10000.0;\n\tvelkt = -1.0;\n\tnumsat = -1;\n\thdop = 100;\n    \n    while (ss(&gpsin[x],gpsbuf)>0) {\n        if (_debugEnabled) NSLog(@\"GPS record: %s\", gpsbuf);//uncommented\n        if(_tripmateMode && (!strncmp(gpsbuf, \"ASTRAL\", 6))) {\n            write(fd, \"ASTRAL\\r\", 7);\n        } else if(strncmp(gpsbuf, \"$GPGGA\", 6) == 0) {  //gpsbuf contains GPS fixed data (almost everything poss)\n            if (sscanf(gpsbuf, \"%*[^,],%*f,%2d%f,%c,%3d%f,%c,%d,%d,%f,%f\",\n\t\t&nsh, &ns.coordinates, &ns.dir,\n                &ewh, &ew.coordinates, &ew.dir,\n\t        &valid, &numsat, &hdop, &elev.coordinates)>=7) { // this probably should be == 10 not >= 7  more testing\n                \t\t\n                if (valid) _reliable = YES;\n                else _reliable = NO;\n                \n                if (_debugEnabled) NSLog(@\"GPS data updated.\");\n                updated = YES;\n            }\n        } else if(strncmp(gpsbuf, \"$GPRMC\", 6) == 0) {  //gpsbuf contains Recommended minimum specific GPS/TRANSIT data !!does not include elevation\n            if (sscanf(gpsbuf, \"%*[^,],%*f,%c,%2d%f,%c,%3d%f,%c,%f,%d,\",\n                &cvalid, &nsh, &ns.coordinates, &ns.dir,\n                &ewh, &ew.coordinates, &ew.dir, &velkt, &veldir)==9) {\n            \n                if (cvalid == 'A') _reliable = YES;\n                else _reliable = NO;\n                \n                if (_debugEnabled) NSLog(@\"GPS data updated.\");  \n                updated = YES;\n            }\n        } else if(strncmp(gpsbuf, \"$GPGLL\", 6) == 0) {  //gbsbuf contains Geographical postiion, latitude and longitude only  !!does not include elevation\n            if (sscanf(gpsbuf, \"%*[^,],%2d%f,%c,%3d%f,%c,%*f,%c\",\n                &nsh, &ns.coordinates, &ns.dir,\n                &ewh, &ew.coordinates, &ew.dir, &cvalid)==7) {\n            \n                if (cvalid == 'A') _reliable = YES;\n                else _reliable = NO;\n                \n                if (_debugEnabled) NSLog(@\"GPS data updated.\");  \n                updated = YES;\n            }\n        }\n        \n        x+=strlen(gpsbuf)+1;\n    }\n    \n    q+=len-x;\n    memcpy(gpsbuf,&gpsin[x],q);\n    memcpy(gpsin,gpsbuf,q);\n    if (q>80) q=0;\n    \n\tdate = [[NSDate alloc] init];\n    \n\tif (updated) {\n        if (_reliable) {\n            if (([_lastUpdate timeIntervalSinceDate:_lastAdd]>_traceInterval) && (_traceInterval != 100)) {\n                waypoint w;\n                w._lat  = _ns.coordinates * ((_ns.dir=='N') ? 1.0 : -1.0);\n                w._long = _ew.coordinates * ((_ew.dir=='E') ? 1.0 : -1.0);\n                if ([[WaveHelper trace] addPoint:w]) [WaveHelper secureReplace:&_lastAdd withObject:date];\n            }\n        } else {\n            [[WaveHelper trace] cut];\n        }\n\t\ttimeinterval = [date timeIntervalSinceDate:_lastUpdate];\n        [WaveHelper secureReplace:&_lastUpdate withObject:date];\n\n        if ((_reliable)||(_onNoFix==0)) {\n            if (ns.dir != 'S') _ns.dir = 'N';\n            else _ns.dir = 'S';\n            \n            if (ew.dir != 'W') _ew.dir = 'E';\n            else _ew.dir = 'W';\n            \n            _ns.coordinates   = nsh + ns.coordinates / 60.0;\n            _ew.coordinates   = ewh + ew.coordinates / 60.0;\n            if (elev.coordinates > -10000.00) _elev.coordinates = elev.coordinates;\n\t\t\t\n            if (velkt > -1.0) {\n\t\t\t\tif ((velkt > 0) && (_velkt==0)) {\n\t\t\t\t\t_peakvel = 0;\n\t\t\t\t\t_sectordist = 0;\n\t\t\t\t\t_sectortime = 0;\n\t\t\t\t\t[WaveHelper secureReplace:&_sectorStart withObject:date];\n\t\t\t\t} else if ((velkt > 0) || (_velkt > 0)) {\n\t\t\t\t\t// update distances only if we're moving (or just stopped)\n\t\t\t\t\tdisplacement = (velkt + _velkt)*timeinterval/7200;\n\t\t\t\t\t_sectordist += displacement;\n\t\t\t\t\t_sectortime += timeinterval;\n\t\t\t\t\t_totaldist += displacement;\n\t\t\t\t}\n                _velkt = velkt;\n                _veldir = veldir;\n\t\t\t\tif (velkt > _peakvel) _peakvel = velkt;\n\t\t\t\tif (velkt > _maxvel) _maxvel = velkt;\n\t\t\t}\n            \n            if (numsat > -1) {\n                _numsat = numsat;\n                _hdop = hdop;\n            }\n        } else if(_onNoFix==2) {\n            _ns.dir = 'N';\n            _ew.dir = 'E';\n            \n            _elev.coordinates = 0;\n            _ns.coordinates = 0;\n            _ew.coordinates = 0;\n            _velkt = 0;\n        }\n    }\n    \n    [subpool release];\n\t[date release];\n    \n    return YES;\n}\n\n- (bool)gpsd_parse:(int) fd {\n    int len, valid, numsat, veldir;\n    char gpsbuf[MAX_GPSBUF_LEN];\n    double ns, ew, elev;\n\tfloat velkt,hdop,fveldir;\n\tfloat timeinterval=-1;\n\tfloat displacement;\n    NSDate *date;\n    NSAutoreleasePool* subpool = [[NSAutoreleasePool alloc] init];\n\n    if (_debugEnabled) NSLog(@\"GPSd write command\");\n    \n    if (write(fd, \"PAMVTQ\\r\\n\", 8) < 8) {\n        NSLog(@\"GPSd write failed\");\n        return NO;\n    }\n    \n    if((len = read(fd, &gpsbuf[0], MAX_GPSBUF_LEN)) < 0) {\n        NSLog(@\"GPSd read failed\");\n        return NO;\n    }\n    if (len == 0) return YES;\n    \n    if (_debugEnabled) NSLog(@\"GPSd read data returned.\");\n    [self setStatus:nil];\n    _linesRead++;\n    \n    gpsbuf[0+len]=0;\n \tnumsat = -1;\n\thdop = 100;\n   \n\tdate = [[NSDate alloc] init];\n\n\tif (sscanf(gpsbuf, \"GPSD,P=%lg %lg,A=%lg,M=%d,V=%f,T=%f,Q=%d %*f %f\",\n        &ns, &ew, &elev, &valid, &velkt, &fveldir, &numsat, &hdop) >=6) {\n                        \n        if (valid >= 2) _reliable = YES;\n        else _reliable = NO;\n        \n        if (_debugEnabled) NSLog(@\"GPSd data updated.\");\n\t\t\n\t\tif (_reliable) {\n            if (([_lastUpdate timeIntervalSinceDate:_lastAdd]>_traceInterval) && (_traceInterval != 100)) {\n                waypoint w;\n                w._lat  = _ns.coordinates * ((_ns.dir=='N') ? 1.0 : -1.0);\n                w._long = _ew.coordinates * ((_ew.dir=='E') ? 1.0 : -1.0);\n                if ([[WaveHelper trace] addPoint:w]) [WaveHelper secureReplace:&_lastAdd withObject:date];\n            }\n        } else {\n            [[WaveHelper trace] cut];\n        }\n\t\ttimeinterval = [date timeIntervalSinceDate:_lastUpdate];\n        [WaveHelper secureReplace:&_lastUpdate withObject:date];\n\n\n        if ((_reliable)||(_onNoFix==0)) {\n            if (ns >= 0) _ns.dir = 'N';\n            else _ns.dir = 'S';\n            \n            if (ew >= 0) _ew.dir = 'E';\n            else _ew.dir = 'W';\n            \n            _ns.coordinates   = fabs(ns);\n            _ew.coordinates   = fabs(ew);\n            _elev.coordinates = elev;\n\t\t\tif ((velkt > 0) && (_velkt==0)) {\n\t\t\t\t_peakvel = 0;\n\t\t\t\t_sectordist = 0;\n\t\t\t\t_sectortime = 0;\n\t\t\t\t[WaveHelper secureReplace:&_sectorStart withObject:date];\n\t\t\t} else if ((velkt > 0) || (_velkt > 0)) {\n\t\t\t\t// update distances only if we're moving (or just stopped)\n\t\t\t\tdisplacement = (velkt + _velkt)*timeinterval/7200;\n\t\t\t\t_sectordist += displacement;\n\t\t\t\t_sectortime += timeinterval;\n\t\t\t\t_totaldist += displacement;\n\t\t\t}\n\t\t\t_velkt = velkt;\n\t\t\tveldir = (int)fveldir;\n\t\t\t_veldir = veldir;\n\t\t\tif (velkt > _peakvel) _peakvel = velkt;\n\t\t\tif (velkt > _maxvel) _maxvel = velkt;\n\n\t\t\tif (numsat > -1) {\n\t\t\t\t_numsat = numsat;\n\t\t\t\t_hdop = hdop;\n\t\t\t}\n\t\t} else if(_onNoFix==2) {\n            _ns.dir = 'N';\n            _ew.dir = 'E';\n            \n            _elev.coordinates = 0;\n            _ns.coordinates = 0;\n            _ew.coordinates = 0;\n            _velkt = 0;\n        }\n    } else {\n        NSLog(@\"GPSd parsing failure\");\n    }\n    \n    [subpool release];\n\t[date release];\n    \n    return YES;\n}\n\n- (void) continousParse:(int) fd {\n    NSDate *date;\n    unsigned int i = 0;\n    NSAutoreleasePool* subpool;\n\t\n    while (_gpsShallRun && [self gps_parse:fd]) {\n\t\tsubpool = [[NSAutoreleasePool alloc] init];\n        //actually once a sec should be enough, but sometimes we dont get any information. so do it more often.\n        if ((i++ % 10 == 0) && (_status == Nil))\n            [[NSNotificationCenter defaultCenter] postNotificationName:KisMACGPSStatusChanged object:[self status]];\n        date = [[NSDate alloc] initWithTimeIntervalSinceNow:0.1];\n        [NSThread sleepUntilDate:date];\n        [date release];\n\t\t[subpool release];\n    }\n}\n\n- (void) continousParseGPSd:(int) fd {\n    NSDate *date;\n    unsigned int i = 0;\n\tNSAutoreleasePool* subpool;\n\n    while (_gpsShallRun && [self gpsd_parse:fd]) {\n\t\tsubpool = [[NSAutoreleasePool alloc] init];\n        if ((i++ % 2 == 0) && (_status == Nil))\n            [[NSNotificationCenter defaultCenter] postNotificationName:KisMACGPSStatusChanged object:[self status]];\n        date = [[NSDate alloc] initWithTimeIntervalSinceNow:0.5];\n        [NSThread sleepUntilDate:date];\n        [date release];\n\t\t[subpool release];\n    }\n}\n\n- (void)gpsThreadSerial:(id)object {\n    NSAutoreleasePool* subpool = [[NSAutoreleasePool alloc] init];\n    int     handshake;\n    struct  termios backup;\n\n    _gpsShallRun = NO;\n    \n    if ([_gpsLock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:10]]) {\n        _gpsThreadUp = YES;\n        _gpsShallRun = YES;\n        [_lastUpdate release];\n        _lastUpdate = nil;\n        [_sectorStart release];\n        _sectorStart = nil;\n        \n        [self setStatus:NSLocalizedString(@\"GPS subsystem starting up.\", @\"GPS status\")];\n\n        //NSLog(@\"Starting GPS device\");\n        if((_serialFD = open([_gpsDevice cString], O_RDWR | O_NOCTTY | O_NONBLOCK )) < 0) {\n            NSLog(@\"error: unable to open gps device: %s\", strerror(errno));\n            [self setStatus:NSLocalizedString(@\"Could not open GPS.\", @\"GPS status\")];\n        } else if(!isatty(_serialFD)) {\n            NSLog(@\"error: specified gps device is not a tty: %s\", strerror(errno));\n        } else if (ioctl(_serialFD, TIOCEXCL) == -1) {\n            NSLog(@\"error: could not set exclusive flag: %s\", strerror(errno));\n        } else if (fcntl(_serialFD, F_SETFL, 0) == -1) {\n            NSLog(@\"error: clearing O_NONBLOCK: %s(%d).\\n\", strerror(errno), errno);\n        } else if(tcgetattr(_serialFD, &backup) != 0) {\n            NSLog(@\"error: unable to set attributes for gps device: %s\", strerror(errno));\n        } else if(ioctl(_serialFD, TIOCGETA, &ttyset) < 0) {\n            NSLog(@\"error: unable to ioctl gps device: %s\", strerror(errno));\n        } else {\n            //NSLog(@\"GPS device is open\");\n            ttyset.c_ispeed = B4800;\n            ttyset.c_ospeed = B4800;\n            \n            ttyset.c_cflag |=       CRTSCTS;    // hadware flow on\n            ttyset.c_cflag &=       ~PARENB;    // no parity\n            ttyset.c_cflag &=       ~CSTOPB;    // one stopbit\n            ttyset.c_cflag &=       CSIZE;\n            ttyset.c_cflag |=       CS8;        // 8N1\n            ttyset.c_cflag |=       (CLOCAL | CREAD); //enable Localmode, receiver\n            ttyset.c_cc[VMIN] =     20;         // set min read chars if 0  VTIME takes over\n            ttyset.c_cc[VTIME] =    10;         // wait x ms for charakter\n\n            //options.c_cflag &= ~ ICANON; // canonical input \n            ttyset.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);\n\n            \n            if(ioctl(_serialFD, TIOCSETAF, &ttyset) < 0) {\n                NSLog(@\"error: unable to ioctl gps device: %s\", strerror(errno));\n            } else {\n                if (ioctl(_serialFD, TIOCSDTR) == -1) { // Assert Data Terminal Ready (DTR)\n                    NSLog(@\"Error asserting DTR - %s(%d).\\n\", strerror(errno), errno);\n                }\n                \n                if (ioctl(_serialFD, TIOCCDTR) == -1) { // Clear Data Terminal Ready (DTR) \n                    NSLog(@\"Error clearing DTR - %s(%d).\\n\", strerror(errno), errno);\n                }\n                \n                handshake = TIOCM_DTR | TIOCM_RTS | TIOCM_CTS | TIOCM_DSR;\n                if (ioctl(_serialFD, TIOCMSET, &handshake) == -1) { // Set the modem lines depending on the bits set in handshake\n                    NSLog(@\"Error setting handshake lines - %s(%d).\\n\", strerror(errno), errno);\n                }\n                \n                if (ioctl(_serialFD, TIOCMGET, &handshake) == -1) { // Store the state of the modem lines in handshake\n                    NSLog(@\"Error getting handshake lines - %s(%d).\\n\", strerror(errno), errno);\n                }\n\n                NSLog(@\"GPS started successfully in serial mode\\n\");\n                [self setStatus:NSLocalizedString(@\"GPS started in serial mode.\", @\"GPS status\")];\n\n                [self continousParse:_serialFD];\n            }\n            \n            if (_serialFD) close(_serialFD);\n            [self setStatus:NSLocalizedString(@\"GPS device closed.\", @\"GPS status\")];\n        }    \n\n        [_gpsLock unlock];\n        _gpsThreadUp = NO;\n    } else {\n        NSLog(@\"GPS LOCKING FAILURE!\");\n    }\n    \n    [subpool release];\n    return;\n}\n\n- (void)gpsThreadGPSd:(id)object {\n    int sockd;\n    struct sockaddr_in serv_name;\n    int status;\n    struct hostent *hp;\n    UInt32 ip;\n    NSUserDefaults *sets;\n    const char *hostname;\n    NSAutoreleasePool* subpool = [[NSAutoreleasePool alloc] init];\n    \n    _gpsShallRun = NO;\n    \n    if ([_gpsLock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:10]]) {\n        _gpsThreadUp = YES;\n        _gpsShallRun = YES;\n        [_lastUpdate release];\n        _lastUpdate = nil;\n        [_sectorStart release];\n        _sectorStart = nil;\n        \n        [self setStatus:NSLocalizedString(@\"Starting GPS in GPSd mode.\", @\"GPS status\")];\n\n        sets = [NSUserDefaults standardUserDefaults];\n        \n        sockd  = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockd == -1) {\n            NSLog(@\"Socket creation failed!\");\n            goto err;\n        }\n        \n        hostname = [[sets objectForKey:@\"GPSDaemonHost\"] cString];\n        \n        if (inet_addr(hostname) != INADDR_NONE) {\n            ip = inet_addr(hostname);\n        } else {\n            hp = gethostbyname(hostname);\n            if (hp == NULL) {\n                NSLog(@\"Could not resolve %s\", hostname);\n                goto err;\n            }\n            ip = *(int *)hp->h_addr_list[0];\n        }\n        \n        /* server address */\n        serv_name.sin_addr.s_addr = ip;\n        serv_name.sin_family = AF_INET;\n        serv_name.sin_port = htons([sets integerForKey:@\"GPSDaemonPort\"]);\n\n        NSLog(@\"Connecting to gpsd (%s)\",inet_ntoa(serv_name.sin_addr));\n\n        /* connect to the server */\n        status = connect(sockd, (struct sockaddr*)&serv_name, sizeof(serv_name));\n        \n        if (status == -1) {\n            NSLog(@\"Could not connect to %s port %d\", hostname, [sets integerForKey:@\"GPSDaemonPort\"]);\n            goto err;\n        }\n\n        NSLog(@\"GPS started successfully in GPSd mode.\\n\");\n        [self setStatus:NSLocalizedString(@\"GPS started in GPSd mode.\", @\"GPS status\")];\n\n        [self continousParseGPSd: sockd];\n        close(sockd);\n\n        [self setStatus:NSLocalizedString(@\"GPSd connection terminated.\", @\"GPS status\")];\n    err:\n        [_gpsLock unlock];\n        _gpsThreadUp = NO;\n    } else {\n        NSLog(@\"GPS LOCKING FAILURE!\");\n    }\n\n    [subpool release];\n    return;\n}\n\n#pragma mark -\n\n- (void)writeDebugOutput:(BOOL)enable {\n    _debugEnabled = enable;\n}\n\n#pragma mark -\n\n- (void)stop {\n    int fd;\n    _gpsShallRun=NO;\n\n    [self setStatus:NSLocalizedString(@\"Trying to terminate GPS subsystem.\", @\"GPS status\")];\n    \n    if ([_gpsLock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:0.5]]) {\n        [_gpsLock unlock];\n    } else {\n        //kill the file descriptor if cannot obtain a lock\n        if (_serialFD) {\n            fd = _serialFD;\n            _serialFD = 0;\n            close(fd);\n        }\n    }\n}\n\n- (void) dealloc {\n    [WaveHelper secureRelease:&_status];\n    _gpsShallRun=NO;\n    [_gpsLock release];\n    [_gpsDevice release];\n    [_lastAdd release];\n    [super dealloc];\n}\n\n@end\n";
		rLen = 29083;
		rLoc = 0;
		rType = 0;
		vrLen = 719;
		vrLoc = 28364;
	};
	00766A2B0784506900A30713 = {
		fRef = 0035341C06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = sendFrame;
		rLen = 9;
		rLoc = 4449;
		rType = 0;
		vrLen = 835;
		vrLoc = 4068;
	};
	00766A2C0784506900A30713 = {
		fRef = 003533FB06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "GPSController.m: 818";
		rLen = 0;
		rLoc = 29327;
		rType = 0;
		vrLen = 669;
		vrLoc = 28404;
	};
	00766A38078450FA00A30713 = {
		fRef = 003533FA06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "Michael Rossberg, Robin Darroch";
		rLen = 31;
		rLoc = 81;
		rType = 0;
		vrLen = 1154;
		vrLoc = 0;
	};
	00766A39078450FA00A30713 = {
		fRef = 003533FB06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "GPSController.m: 5";
		rLen = 0;
		rLoc = 112;
		rType = 0;
		vrLen = 1171;
		vrLoc = 0;
	};
	00766A3A078450FA00A30713 = {
		fRef = 003533FA06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "Michael Rossberg, Robin Darroch";
		rLen = 31;
		rLoc = 81;
		rType = 0;
		vrLen = 1154;
		vrLoc = 0;
	};
	00766A430784870600A30713 = {
		fRef = 003533FB06A5DD8500AB4577;
		isa = PBXTextBookmark;
		name = "GPSController.m: 708";
		rLen = 0;
		rLoc = 26117;
		rType = 0;
		vrLen = 945;
		vrLoc = 25486;
	};
	00875D190708ADB300CACFCB = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 1609}}";
			sepNavSelRange = "{0, 936}";
			sepNavVisRect = "{{0, 0}, {964, 478}}";
		};
	};
	00875D1A0708ADB300CACFCB = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 8833}}";
			sepNavSelRange = "{8926, 14}";
			sepNavVisRect = "{{0, 3832}, {862, 330}}";
		};
	};
	00875DA807097D8D00CACFCB = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 573}}";
			sepNavSelRange = "{1169, 0}";
			sepNavVisRect = "{{0, 82}, {964, 478}}";
		};
	};
	00875DA907097D8D00CACFCB = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 1973}}";
			sepNavSelRange = "{1315, 0}";
			sepNavVisRect = "{{0, 440}, {964, 478}}";
		};
	};
	00909C5406DB52A0002FB6AB = {
		fileReference = 0035341606A5DD8500AB4577;
		functionName = "-nextFrame";
		isa = PBXFileBreakpoint;
		lineNumber = 365;
		state = 1;
	};
	0090AC8306E5E3250096C5FC = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 587}}";
			sepNavSelRange = "{1118, 0}";
			sepNavVisRect = "{{0, 64}, {964, 468}}";
		};
	};
	0090AC8406E5E3250096C5FC = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 2365}}";
			sepNavSelRange = "{4012, 5}";
			sepNavVisRect = "{{0, 1884}, {964, 468}}";
			sepNavWindowFrame = "{{15, 269}, {750, 558}}";
		};
	};
	00971F3C06E4FA6F004307EA = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 601}}";
			sepNavSelRange = "{958, 0}";
			sepNavVisRect = "{{0, 123}, {964, 478}}";
		};
	};
	00971F3D06E4FA6F004307EA = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {959, 1455}}";
			sepNavSelRange = "{1755, 0}";
			sepNavVisRect = "{{0, 711}, {959, 283}}";
		};
	};
	00971F5406E4FFBF004307EA = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 755}}";
			sepNavSelRange = "{1105, 6}";
			sepNavVisRect = "{{0, 277}, {964, 478}}";
		};
	};
	00971F5506E4FFBF004307EA = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 2099}}";
			sepNavSelRange = "{2334, 61}";
			sepNavVisRect = "{{0, 1294}, {964, 478}}";
		};
	};
	0097241206E51844004307EA = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 559}}";
			sepNavSelRange = "{1011, 9}";
			sepNavVisRect = "{{0, 0}, {964, 478}}";
		};
	};
	0097241306E51844004307EA = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 1511}}";
			sepNavSelRange = "{999, 11}";
			sepNavVisRect = "{{0, 154}, {964, 478}}";
			sepNavWindowFrame = "{{15, 269}, {750, 558}}";
		};
	};
	0097243706E51A99004307EA = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {968, 671}}";
			sepNavSelRange = "{1270, 0}";
			sepNavVisRect = "{{0, 126}, {968, 484}}";
		};
	};
	0097243806E51A99004307EA = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {968, 2589}}";
			sepNavSelRange = "{40, 0}";
			sepNavVisRect = "{{0, 0}, {968, 484}}";
		};
	};
	009B192106FC83A800E8883A = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {963, 690}}";
			sepNavSelRange = "{28, 15}";
			sepNavVisRect = "{{0, 0}, {963, 690}}";
		};
	};
	009B192206FC83A800E8883A = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 1175}}";
			sepNavSelRange = "{1296, 0}";
			sepNavVisRect = "{{0, 280}, {964, 468}}";
		};
	};
	009D64F206FF73BA00B0F1EC = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 3009}}";
			sepNavSelRange = "{6702, 0}";
			sepNavVisRect = "{{0, 2478}, {964, 468}}";
		};
	};
	009F5C5D06A5C8DF004BB18E = {
		activeArgIndex = 2147483647;
		activeArgIndices = (
		);
		argumentStrings = (
		);
		configStateDict = {
		};
		cppStopOnCatchEnabled = 0;
		cppStopOnThrowEnabled = 0;
		customDataFormattersEnabled = 1;
		debuggerPlugin = GDBDebugging;
		disassemblyDisplayState = 0;
		dylibVariantSuffix = "";
		enableDebugStr = 1;
		environmentEntries = (
		);
		isa = PBXExecutable;
		libgmallocEnabled = 0;
		name = KisMAC;
		savedGlobals = {
		};
		shlibInfoDictList = (
		);
		sourceDirectories = (
		);
	};
	009F5C6006A5C8FF004BB18E = {
		fallbackIsa = XCSourceControlManager;
		isSCMEnabled = 1;
		isa = PBXSourceControlManager;
		scmConfiguration = {
		};
		scmType = scm.subversion;
	};
	009F5C6106A5C8FF004BB18E = {
		indexTemplatePath = "";
		isa = PBXCodeSenseManager;
		usesDefaults = 0;
		wantsCodeCompletion = 1;
		wantsCodeCompletionAutoSuggestions = 1;
		wantsCodeCompletionCaseSensitivity = 1;
		wantsCodeCompletionListAlways = 1;
		wantsCodeCompletionOnlyMatchingItems = 1;
		wantsCodeCompletionParametersIncluded = 1;
		wantsCodeCompletionPlaceholdersInserted = 1;
		wantsCodeCompletionTabCompletes = 1;
		wantsIndex = 1;
	};
	00A622A706FEE4FB005D248A = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {1239, 685}}";
			sepNavSelRange = "{847, 0}";
			sepNavVisRect = "{{0, 0}, {1239, 425}}";
		};
	};
	00A622A806FEE4FB005D248A = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 1749}}";
			sepNavSelRange = "{3330, 0}";
			sepNavVisRect = "{{0, 1281}, {964, 468}}";
		};
	};
	00B6296607058E2B006FC563 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 545}}";
			sepNavSelRange = "{0, 946}";
			sepNavVisRect = "{{0, 0}, {964, 478}}";
		};
	};
	00B6296707058E2B006FC563 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 1105}}";
			sepNavSelRange = "{1780, 0}";
			sepNavVisRect = "{{0, 456}, {964, 468}}";
		};
	};
	00C5F12A06DE0C98001EC02F = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 587}}";
			sepNavSelRange = "{1215, 0}";
			sepNavVisRect = "{{0, 105}, {964, 468}}";
			sepNavWindowFrame = "{{61, 227}, {750, 558}}";
		};
	};
	00C5F12B06DE0C98001EC02F = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 2589}}";
			sepNavSelRange = "{2242, 18}";
			sepNavVisRect = "{{0, 834}, {964, 468}}";
		};
	};
	00C5F13206DE0EAF001EC02F = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 517}}";
			sepNavSelRange = "{1076, 12}";
			sepNavVisRect = "{{0, 0}, {964, 478}}";
		};
	};
	00CBA25806DB7D09000ACD19 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {968, 666}}";
			sepNavSelRange = "{1060, 0}";
			sepNavVisRect = "{{0, 0}, {968, 666}}";
		};
	};
	00CBA25906DB7D0A000ACD19 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 4787}}";
			sepNavSelRange = "{1880, 0}";
			sepNavVisRect = "{{0, 432}, {964, 478}}";
		};
	};
	00CBA33E06DB8FDE000ACD19 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 1567}}";
			sepNavSelRange = "{2844, 35}";
			sepNavVisRect = "{{0, 1050}, {964, 468}}";
		};
	};
	00CBA33F06DB8FDE000ACD19 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 8441}}";
			sepNavSelRange = "{17520, 0}";
			sepNavVisRect = "{{0, 7924}, {964, 468}}";
			sepNavWindowFrame = "{{38, 248}, {750, 558}}";
		};
	};
	00D135D00707EA3A00D85D30 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 1357}}";
			sepNavSelRange = "{3806, 29}";
			sepNavVisRect = "{{0, 867}, {964, 478}}";
			sepNavWindowFrame = "{{38, 248}, {750, 558}}";
		};
	};
	00D135D10707EA3A00D85D30 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 8623}}";
			sepNavSelRange = "{11582, 0}";
			sepNavVisRect = "{{0, 6129}, {964, 468}}";
		};
	};
	00E1426B06E62A44009DC179 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {963, 690}}";
			sepNavSelRange = "{1009, 11}";
			sepNavVisRect = "{{0, 0}, {963, 690}}";
			sepNavWindowFrame = "{{15, 269}, {750, 558}}";
		};
	};
	00E1426C06E62A44009DC179 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {862, 2897}}";
			sepNavSelRange = "{5673, 14}";
			sepNavVisRect = "{{0, 2432}, {862, 330}}";
		};
	};
	00ED80A606E32C9600455A05 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {963, 727}}";
			sepNavSelRange = "{1142, 0}";
			sepNavVisRect = "{{0, 0}, {963, 690}}";
		};
	};
	00ED80A706E32C9600455A05 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 2561}}";
			sepNavSelRange = "{2068, 0}";
			sepNavVisRect = "{{0, 2083}, {964, 478}}";
		};
	};
	00F57C4B06A886630035AE2F = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 478}}";
			sepNavSelRange = "{279, 0}";
			sepNavVisRect = "{{0, 0}, {964, 478}}";
		};
	};
	00F57C4C06A886630035AE2F = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 11213}}";
			sepNavSelRange = "{28024, 0}";
			sepNavVisRect = "{{0, 10710}, {964, 478}}";
		};
	};
	00F57CAB06A8887F0035AE2F = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 3962}}";
			sepNavSelRange = "{122, 0}";
			sepNavVisRect = "{{0, 0}, {964, 478}}";
		};
	};
	00F57CAC06A8887F0035AE2F = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 727}}";
			sepNavSelRange = "{90, 0}";
			sepNavVisRect = "{{0, 0}, {964, 468}}";
		};
	};
	00F57CBC06A99A8B0035AE2F = {
		fileReference = 0035341406A5DD8500AB4577;
		functionName = "+loadBackend";
		isa = PBXFileBreakpoint;
		lineNumber = 93;
		state = 1;
	};
	00F9C6B506DB3F2100E357F0 = {
		fileReference = 0035341606A5DD8500AB4577;
		functionName = "-nextFrame";
		isa = PBXFileBreakpoint;
		lineNumber = 370;
		state = 1;
	};
	00FF593C06C630CC006C7F1E = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 587}}";
			sepNavSelRange = "{884, 0}";
			sepNavVisRect = "{{0, 0}, {964, 463}}";
			sepNavWindowFrame = "{{15, 269}, {750, 558}}";
		};
	};
	00FF593D06C630CC006C7F1E = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {2204, 2716}}";
			sepNavSelRange = "{10168, 0}";
			sepNavVisRect = "{{0, 434}, {964, 463}}";
		};
	};
	29B97313FDCFA39411CA2CEA = {
		activeBuildStyle = 4A9504CCFFE6A4B311CA0CBA;
		activeExecutable = 009F5C5D06A5C8DF004BB18E;
		activeTarget = 8D1107260486CEB800E47090;
		addToTargets = (
			8D1107260486CEB800E47090,
		);
		breakpoints = (
			00F57CBC06A99A8B0035AE2F,
			00F9C6B506DB3F2100E357F0,
			00909C5406DB52A0002FB6AB,
			002F187907003E5A004F5FEF,
		);
		codeSenseManager = 009F5C6106A5C8FF004BB18E;
		executables = (
			009F5C5D06A5C8DF004BB18E,
		);
		expressions = (
			"(self)->_networkView",
			_importOpen,
		);
		perUserDictionary = {
			PBXConfiguration.PBXFileTableDataSource3.PBXBookmarksDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXBookmarksDataSource_NameID;
				PBXFileTableDataSourceColumnWidthsKey = (
					327.2085,
					312.5991,
					339.5835,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXBookmarksDataSource_LocationID,
					PBXBookmarksDataSource_NameID,
					PBXBookmarksDataSource_CommentsID,
				);
			};
			PBXConfiguration.PBXFileTableDataSource3.PBXErrorsWarningsDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXErrorsWarningsDataSource_LocationID;
				PBXFileTableDataSourceColumnWidthsKey = (
					20,
					645.8799,
					344.2085,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXErrorsWarningsDataSource_TypeID,
					PBXErrorsWarningsDataSource_MessageID,
					PBXErrorsWarningsDataSource_LocationID,
				);
			};
			PBXConfiguration.PBXFileTableDataSource3.PBXExecutablesDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXExecutablesDataSource_NameID;
				PBXFileTableDataSourceColumnWidthsKey = (
					22,
					991.7974,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXExecutablesDataSource_ActiveFlagID,
					PBXExecutablesDataSource_NameID,
				);
			};
			PBXConfiguration.PBXFileTableDataSource3.PBXFileTableDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXFileDataSource_Filename_ColumnID;
				PBXFileTableDataSourceColumnWidthsKey = (
					20,
					691,
					20,
					123,
					43,
					43,
					20,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXFileDataSource_FiletypeID,
					PBXFileDataSource_Filename_ColumnID,
					PBXFileDataSource_Built_ColumnID,
					PBXFileDataSource_ObjectSize_ColumnID,
					PBXFileDataSource_Errors_ColumnID,
					PBXFileDataSource_Warnings_ColumnID,
					PBXFileDataSource_Target_ColumnID,
				);
			};
			PBXConfiguration.PBXFileTableDataSource3.PBXSymbolsDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXSymbolsDataSource_SymbolNameID;
				PBXFileTableDataSourceColumnWidthsKey = (
					16,
					306.8008,
					336.0356,
					313.2085,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXSymbolsDataSource_SymbolTypeIconID,
					PBXSymbolsDataSource_SymbolNameID,
					PBXSymbolsDataSource_SymbolTypeID,
					PBXSymbolsDataSource_ReferenceNameID,
				);
			};
			PBXConfiguration.PBXFileTableDataSource3.XCSCMDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXFileDataSource_Filename_ColumnID;
				PBXFileTableDataSourceColumnWidthsKey = (
					20,
					20,
					684,
					20,
					106,
					43,
					43,
					20,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXFileDataSource_SCM_ColumnID,
					PBXFileDataSource_FiletypeID,
					PBXFileDataSource_Filename_ColumnID,
					PBXFileDataSource_Built_ColumnID,
					PBXFileDataSource_ObjectSize_ColumnID,
					PBXFileDataSource_Errors_ColumnID,
					PBXFileDataSource_Warnings_ColumnID,
					PBXFileDataSource_Target_ColumnID,
				);
			};
			PBXConfiguration.PBXTargetDataSource.PBXTargetDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXFileDataSource_Filename_ColumnID;
				PBXFileTableDataSourceColumnWidthsKey = (
					20,
					586,
					124,
					20,
					124,
					43,
					43,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXFileDataSource_FiletypeID,
					PBXFileDataSource_Filename_ColumnID,
					PBXTargetDataSource_PrimaryAttribute,
					PBXFileDataSource_Built_ColumnID,
					PBXFileDataSource_ObjectSize_ColumnID,
					PBXFileDataSource_Errors_ColumnID,
					PBXFileDataSource_Warnings_ColumnID,
				);
			};
			PBXPerProjectTemplateStateSaveDate = 126461447;
			PBXPrepackagedSmartGroups_v2 = (
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					activationKey = OldTargetSmartGroup;
					clz = PBXTargetSmartGroup;
					description = "Displays all targets of the project.";
					globalID = 1C37FABC04509CD000000102;
					name = Targets;
					preferences = {
						image = Targets;
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = PBXTargetSmartGroup2;
					description = "Displays all targets of the project as well as nested build phases.";
					globalID = 1C37FBAC04509CD000000102;
					name = Targets;
					preferences = {
						image = Targets;
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = PBXExecutablesSmartGroup;
					description = "Displays all executables of the project.";
					globalID = 1C37FAAC04509CD000000102;
					name = Executables;
					preferences = {
						image = Executable;
					};
				},
				{
					" PBXTransientLocationAtTop " = bottom;
					absolutePathToBundle = "";
					clz = PBXErrorsWarningsSmartGroup;
					description = "Displays files with errors or warnings.";
					globalID = 1C08E77C0454961000C914BD;
					name = "Errors and Warnings";
					preferences = {
						fnmatch = "";
						image = WarningsErrors;
						recursive = 1;
						regex = "";
						root = "<PROJECT>";
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = PBXFilenameSmartGroup;
					description = "Filters items in a given group (potentially recursively) based on matching the name with the regular expression of the filter.";
					globalID = 1CC0EA4004350EF90044410B;
					name = "Implementation Files";
					preferences = {
						canSave = 1;
						fnmatch = "";
						image = SmartFolder;
						isLeaf = 0;
						recursive = 1;
						regex = "?*\\.[mcMC]";
						root = "<PROJECT>";
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = PBXFilenameSmartGroup;
					description = "This group displays Interface Builder NIB Files.";
					globalID = 1CC0EA4004350EF90041110B;
					name = "NIB Files";
					preferences = {
						canSave = 1;
						fnmatch = "*.nib";
						image = SmartFolder;
						isLeaf = 0;
						recursive = 1;
						regex = "";
						root = "<PROJECT>";
					};
				},
				{
					PBXTransientLocationAtTop = no;
					absolutePathToBundle = "";
					clz = PBXFindSmartGroup;
					description = "Displays Find Results.";
					globalID = 1C37FABC05509CD000000102;
					name = "Find Results";
					preferences = {
						image = spyglass;
					};
				},
				{
					PBXTransientLocationAtTop = no;
					absolutePathToBundle = "";
					clz = PBXBookmarksSmartGroup;
					description = "Displays Project Bookmarks.";
					globalID = 1C37FABC05539CD112110102;
					name = Bookmarks;
					preferences = {
						image = Bookmarks;
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = XCSCMSmartGroup;
					description = "Displays files with interesting SCM status.";
					globalID = E2644B35053B69B200211256;
					name = SCM;
					preferences = {
						image = PBXRepository;
						isLeaf = 0;
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = PBXSymbolsSmartGroup;
					description = "Displays all symbols for the project.";
					globalID = 1C37FABC04509CD000100104;
					name = "Project Symbols";
					preferences = {
						image = ProjectSymbols;
						isLeaf = 1;
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = PBXFilenameSmartGroup;
					description = "Filters items in a given group (potentially recursively) based on matching the name with the regular expression of the filter.";
					globalID = PBXTemplateMarker;
					name = "Simple Filter SmartGroup";
					preferences = {
						canSave = 1;
						fnmatch = "*.nib";
						image = SmartFolder;
						isLeaf = 0;
						recursive = 1;
						regex = "";
						root = "<PROJECT>";
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = PBXFilenameSmartGroup;
					description = "Filters items in a given group (potentially recursively) based on matching the name with the regular expression of the filter.";
					globalID = PBXTemplateMarker;
					name = "Simple Regular Expression SmartGroup";
					preferences = {
						canSave = 1;
						fnmatch = "";
						image = SmartFolder;
						isLeaf = 0;
						recursive = 1;
						regex = "?*\\.[mcMC]";
						root = "<PROJECT>";
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					clz = XDDesignSmartGroup;
					description = "Displays Xdesign models";
					globalID = 2E4A936305E6979E00701470;
					name = Design;
					preferences = {
						image = Design;
						isLeaf = 0;
					};
				},
			);
			PBXWorkspaceContents = (
				{
					PBXProjectWorkspaceModule_StateKey_Rev39 = {
						PBXProjectWorkspaceModule_DataSourceSelectionKey_Rev6 = {
							BoundsStr = "{{0, 0}, {1022, 689}}";
							Rows = (
								0,
							);
							VisibleRectStr = "{{0, 0}, {1022, 689}}";
						};
						PBXProjectWorkspaceModule_EditorOpen = false;
						PBXProjectWorkspaceModule_EmbeddedNavigatorGroup = {
							PBXSplitModuleInNavigatorKey = {
								SplitCount = 1;
							};
						};
						PBXProjectWorkspaceModule_GeometryKey_Rev15 = {
							PBXProjectWorkspaceModule_SGTM_Geometry = {
								_collapsingFrameDimension = 0;
								_indexOfCollapsedView = 0;
								_percentageOfCollapsedView = 0;
								sizes = (
									"{{0, 0}, {243, 706}}",
									"{{243, 0}, {1037, 706}}",
								);
							};
						};
						PBXProjectWorkspaceModule_OldDetailFrame = "{{0, 0}, {1037, 706}}";
						PBXProjectWorkspaceModule_OldEditorFrame = "{{0, 0}, {1037, 706}}";
						PBXProjectWorkspaceModule_OldSuperviewFrame = "{{243, 0}, {1037, 706}}";
						PBXProjectWorkspaceModule_SGTM = {
							PBXBottomSmartGroupGIDs = (
								1C37FBAC04509CD000000102,
								1C37FAAC04509CD000000102,
								1C08E77C0454961000C914BD,
								1CC0EA4004350EF90044410B,
								1CC0EA4004350EF90041110B,
								1C37FABC05509CD000000102,
								1C37FABC05539CD112110102,
								E2644B35053B69B200211256,
								1C37FABC04509CD000100104,
							);
							PBXSmartGroupTreeModuleColumnData = {
								PBXSmartGroupTreeModuleColumnWidthsKey = (
									226,
								);
								PBXSmartGroupTreeModuleColumnsKey_v4 = (
									MainColumn,
								);
							};
							PBXSmartGroupTreeModuleOutlineStateKey_v7 = {
								PBXSmartGroupTreeModuleOutlineStateExpansionKey = (
									29B97314FDCFA39411CA2CEA,
									080E96DDFE201D6D7F000001,
									003533A406A5DD8500AB4577,
									003533F406A5DD8500AB4577,
									1C37FBAC04509CD000000102,
								);
								PBXSmartGroupTreeModuleOutlineStateSelectionKey = (
									(
										11,
										6,
										3,
										0,
									),
								);
								PBXSmartGroupTreeModuleOutlineStateVisibleRectKey = "{{0, 0}, {226, 688}}";
							};
							PBXTopSmartGroupGIDs = (
							);
						};
					};
				},
			);
			"PBXWorkspaceContents:PBXConfiguration.PBXModule.PBXBuildResultsModule" = {
			};
			"PBXWorkspaceContents:PBXConfiguration.PBXModule.PBXCVSModule" = {
			};
			"PBXWorkspaceContents:PBXConfiguration.PBXModule.PBXDebugCLIModule" = {
			};
			"PBXWorkspaceContents:PBXConfiguration.PBXModule.PBXDebugSessionModule" = {
				Debugger = {
					HorizontalSplitView = {
						_collapsingFrameDimension = 0;
						_indexOfCollapsedView = 0;
						_percentageOfCollapsedView = 0;
						isCollapsed = yes;
						sizes = (
							"{{0, 0}, {486, 336}}",
							"{{486, 0}, {794, 336}}",
						);
					};
					VerticalSplitView = {
						_collapsingFrameDimension = 0;
						_indexOfCollapsedView = 0;
						_percentageOfCollapsedView = 0;
						isCollapsed = yes;
						sizes = (
							"{{0, 0}, {1280, 336}}",
							"{{0, 336}, {1280, 354}}",
						);
					};
				};
				LauncherConfigVersion = 8;
			};
			"PBXWorkspaceContents:PBXConfiguration.PBXModule.PBXNavigatorGroup" = {
				PBXSplitModuleInNavigatorKey = {
					SplitCount = 1;
				};
			};
			"PBXWorkspaceContents:PBXConfiguration.PBXModule.PBXProjectFindModule" = {
			};
			"PBXWorkspaceContents:PBXConfiguration.PBXModule.PBXProjectWorkspaceModule" = {
				PBXProjectWorkspaceModule_StateKey_Rev39 = {
					PBXProjectWorkspaceModule_DataSourceSelectionKey_Rev6 = {
						BoundsStr = "{{0, 0}, {1022, 3075}}";
						Rows = (
							0,
						);
						VisibleRectStr = "{{0, 0}, {1022, 689}}";
					};
					PBXProjectWorkspaceModule_EditorOpen = false;
					PBXProjectWorkspaceModule_EmbeddedNavigatorGroup = {
						PBXSplitModuleInNavigatorKey = {
							SplitCount = 1;
						};
					};
					PBXProjectWorkspaceModule_GeometryKey_Rev15 = {
						PBXProjectWorkspaceModule_SGTM_Geometry = {
							_collapsingFrameDimension = 0;
							_indexOfCollapsedView = 0;
							_percentageOfCollapsedView = 0;
							sizes = (
								"{{0, 0}, {243, 706}}",
								"{{243, 0}, {1037, 706}}",
							);
						};
					};
					PBXProjectWorkspaceModule_OldDetailFrame = "{{0, 0}, {1037, 706}}";
					PBXProjectWorkspaceModule_OldEditorFrame = "{{0, 0}, {750, 480}}";
					PBXProjectWorkspaceModule_OldSuperviewFrame = "{{243, 0}, {1037, 706}}";
					PBXProjectWorkspaceModule_SGTM = {
						PBXBottomSmartGroupGIDs = (
							1C37FBAC04509CD000000102,
							1C37FAAC04509CD000000102,
							1C08E77C0454961000C914BD,
							1CC0EA4004350EF90044410B,
							1CC0EA4004350EF90041110B,
							1C37FABC05509CD000000102,
							1C37FABC05539CD112110102,
							E2644B35053B69B200211256,
							1C37FABC04509CD000100104,
						);
						PBXSmartGroupTreeModuleColumnData = {
							PBXSmartGroupTreeModuleColumnWidthsKey = (
								226,
							);
							PBXSmartGroupTreeModuleColumnsKey_v4 = (
								MainColumn,
							);
						};
						PBXSmartGroupTreeModuleOutlineStateKey_v7 = {
							PBXSmartGroupTreeModuleOutlineStateExpansionKey = (
								29B97314FDCFA39411CA2CEA,
								080E96DDFE201D6D7F000001,
								19C28FACFE9D520D11CA2CBB,
							);
							PBXSmartGroupTreeModuleOutlineStateSelectionKey = (
								(
									0,
								),
							);
							PBXSmartGroupTreeModuleOutlineStateVisibleRectKey = "{{0, 0}, {226, 688}}";
						};
						PBXTopSmartGroupGIDs = (
						);
					};
				};
			};
			"PBXWorkspaceContents:PBXConfiguration.PBXModule.PBXRunSessionModule" = {
				LauncherConfigVersion = 3;
				Runner = {
					HorizontalSplitView = {
						_collapsingFrameDimension = 0;
						_indexOfCollapsedView = 0;
						_percentageOfCollapsedView = 0;
						isCollapsed = yes;
						sizes = (
							"{{0, 0}, {491, 167}}",
							"{{0, 176}, {491, 267}}",
						);
					};
					VerticalSplitView = {
						_collapsingFrameDimension = 0;
						_indexOfCollapsedView = 0;
						_percentageOfCollapsedView = 0;
						isCollapsed = yes;
						sizes = (
							"{{0, 0}, {405, 443}}",
							"{{414, 0}, {514, 443}}",
						);
					};
				};
			};
			PBXWorkspaceGeometries = (
				{
					Frame = "{{0, 0}, {1280, 706}}";
					PBXProjectWorkspaceModule_GeometryKey_Rev15 = {
					};
					RubberWindowFrame = "0 84 1280 748 0 0 1280 832 ";
				},
			);
			"PBXWorkspaceGeometries:PBXConfiguration.PBXModule.PBXBuildResultsModule" = {
				Frame = "{{0, 0}, {798, 351}}";
				PBXModuleWindowStatusBarHidden = YES;
				RubberWindowFrame = "400 344 798 372 0 0 1280 832 ";
			};
			"PBXWorkspaceGeometries:PBXConfiguration.PBXModule.PBXCVSModule" = {
				Frame = "{{0, 0}, {482, 276}}";
				RubberWindowFrame = "390 300 482 318 0 0 1280 832 ";
			};
			"PBXWorkspaceGeometries:PBXConfiguration.PBXModule.PBXDebugCLIModule" = {
				Frame = "{{0, 0}, {400, 201}}";
				PBXModuleWindowStatusBarHidden = YES;
				RubberWindowFrame = "50 804 400 222 0 0 1280 832 ";
			};
			"PBXWorkspaceGeometries:PBXConfiguration.PBXModule.PBXDebugSessionModule" = {
				DebugConsoleDrawerSize = "{100, 120}";
				DebugConsoleVisible = None;
				DebugConsoleWindowFrame = "{{200, 200}, {500, 300}}";
				DebugSTDIOWindowFrame = "{{200, 200}, {500, 300}}";
				Frame = "{{0, 0}, {1280, 690}}";
				RubberWindowFrame = "0 100 1280 732 0 0 1280 832 ";
			};
			"PBXWorkspaceGeometries:PBXConfiguration.PBXModule.PBXNavigatorGroup" = {
				Frame = "{{0, 0}, {750, 481}}";
				PBXModuleWindowStatusBarHidden = YES;
				RubberWindowFrame = "15 325 750 502 0 0 1280 832 ";
			};
			"PBXWorkspaceGeometries:PBXConfiguration.PBXModule.PBXProjectFindModule" = {
				Frame = "{{0, 0}, {614, 316}}";
				RubberWindowFrame = "333 390 614 358 0 0 1280 832 ";
			};
			"PBXWorkspaceGeometries:PBXConfiguration.PBXModule.PBXProjectWorkspaceModule" = {
				Frame = "{{0, 0}, {1280, 706}}";
				PBXProjectWorkspaceModule_GeometryKey_Rev15 = {
				};
				RubberWindowFrame = "0 84 1280 748 0 0 1280 832 ";
			};
			"PBXWorkspaceGeometries:PBXConfiguration.PBXModule.PBXRunSessionModule" = {
				Frame = "{{0, 0}, {745, 443}}";
				PBXModuleWindowStatusBarHidden = YES;
				RubberWindowFrame = "267 358 745 464 0 0 1280 832 ";
			};
			PBXWorkspaceStateSaveDate = 126461447;
		};
		perUserProjectItems = {
			0046467B0789A61A005B890E = 0046467B0789A61A005B890E;
			0046467E0789A69D005B890E = 0046467E0789A69D005B890E;
			0046467F0789A69D005B890E = 0046467F0789A69D005B890E;
			004646800789A69D005B890E = 004646800789A69D005B890E;
			004646810789A69D005B890E = 004646810789A69D005B890E;
			004646820789A69D005B890E = 004646820789A69D005B890E;
			004646830789A69D005B890E = 004646830789A69D005B890E;
			004646840789A706005B890E = 004646840789A706005B890E;
			004646850789A71F005B890E = 004646850789A71F005B890E;
			004646880789A80A005B890E = 004646880789A80A005B890E;
			004646890789A80A005B890E = 004646890789A80A005B890E;
			0046468A0789A80A005B890E = 0046468A0789A80A005B890E;
			0046468B0789A813005B890E = 0046468B0789A813005B890E;
			0046468C0789A82A005B890E = 0046468C0789A82A005B890E;
			0046468D0789A837005B890E = 0046468D0789A837005B890E;
			0046468E0789A8BC005B890E = 0046468E0789A8BC005B890E;
			006300060764D4FC003B81CC = 006300060764D4FC003B81CC;
			006300080764D4FC003B81CC = 006300080764D4FC003B81CC;
			0063000F0764D9CE003B81CC = 0063000F0764D9CE003B81CC;
			006300200764DC82003B81CC = 006300200764DC82003B81CC;
			006300210764DC82003B81CC = 006300210764DC82003B81CC;
			006302200764FCA8003B81CC = 006302200764FCA8003B81CC;
			006302210764FCA8003B81CC = 006302210764FCA8003B81CC;
			0076657F07844A6400A30713 = 0076657F07844A6400A30713;
			0076658007844A6400A30713 = 0076658007844A6400A30713;
			0076658107844A6400A30713 = 0076658107844A6400A30713;
			0076658407844A6400A30713 = 0076658407844A6400A30713;
			0076658507844A6400A30713 = 0076658507844A6400A30713;
			0076658C0784503B00A30713 = 0076658C0784503B00A30713;
			00766A260784506900A30713 = 00766A260784506900A30713;
			00766A270784506900A30713 = 00766A270784506900A30713;
			00766A2A0784506900A30713 = 00766A2A0784506900A30713;
			00766A2B0784506900A30713 = 00766A2B0784506900A30713;
			00766A2C0784506900A30713 = 00766A2C0784506900A30713;
			00766A38078450FA00A30713 = 00766A38078450FA00A30713;
			00766A39078450FA00A30713 = 00766A39078450FA00A30713;
			00766A3A078450FA00A30713 = 00766A3A078450FA00A30713;
			00766A430784870600A30713 = 00766A430784870600A30713;
		};
		sourceControlManager = 009F5C6006A5C8FF004BB18E;
		userBuildSettings = {
		};
	};
	29B97316FDCFA39411CA2CEA = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {784, 227}}";
			sepNavSelRange = "{195, 0}";
			sepNavVisRect = "{{0, 0}, {784, 227}}";
		};
	};
	32CA4F630368D1EE00C91783 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {996, 689}}";
			sepNavSelRange = "{267, 0}";
			sepNavVisRect = "{{0, 0}, {996, 689}}";
		};
	};
	8D1107260486CEB800E47090 = {
		activeExec = 0;
		executables = (
			009F5C5D06A5C8DF004BB18E,
		);
	};
}
